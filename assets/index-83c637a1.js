(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerpolicy&&(r.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?r.credentials="include":i.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Cr="147",yn={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},An={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Ia=0,Vr=1,La=2,ta=1,Ra=2,Yn=3,Jn=0,Me=1,_e=2,Ye=0,Kn=1,Kr=2,Or=3,Jr=4,Pa=5,Dn=100,Fa=101,Na=102,Br=103,_r=104,Da=200,Va=201,Ka=202,Oa=203,ea=204,na=205,Ja=206,Ba=207,_a=208,Ha=209,Wa=210,qa=0,Ga=1,ja=2,Ar=3,za=4,Qa=5,Za=6,Ya=7,ia=0,Xa=1,$a=2,He=0,to=1,eo=2,no=3,io=4,ro=5,ra=300,Bn=301,_n=302,vr=303,Mr=304,Ri=306,$n=1e3,we=1001,Tr=1002,ce=1003,Hr=1004,Wr=1005,ve=1006,so=1007,Pi=1008,pn=1009,ao=1010,oo=1011,sa=1012,lo=1013,un=1014,hn=1015,ti=1016,co=1017,uo=1018,On=1020,ho=1021,fo=1022,Ee=1023,po=1024,mo=1025,dn=1026,Hn=1027,go=1028,So=1029,xo=1030,bo=1031,yo=1033,Ji=33776,Bi=33777,_i=33778,Hi=33779,qr=35840,Gr=35841,jr=35842,zr=35843,Ao=36196,Qr=37492,Zr=37496,Yr=37808,Xr=37809,$r=37810,ts=37811,es=37812,ns=37813,is=37814,rs=37815,ss=37816,as=37817,os=37818,ls=37819,cs=37820,us=37821,hs=36492,mn=3e3,Ot=3001,vo=3200,Mo=3201,aa=0,To=1,Ce="srgb",ei="srgb-linear",Wi=7680,Uo=519,ds=35044,fs="300 es",Ur=1035;class bn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,t);t.target=null}}}const ne=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],qi=Math.PI/180,kr=180/Math.PI;function ii(){const s=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ne[s&255]+ne[s>>8&255]+ne[s>>16&255]+ne[s>>24&255]+"-"+ne[t&255]+ne[t>>8&255]+"-"+ne[t>>16&15|64]+ne[t>>24&255]+"-"+ne[e&63|128]+ne[e>>8&255]+"-"+ne[e>>16&255]+ne[e>>24&255]+ne[n&255]+ne[n>>8&255]+ne[n>>16&255]+ne[n>>24&255]).toLowerCase()}function ue(s,t,e){return Math.max(t,Math.min(e,s))}function ko(s,t){return(s%t+t)%t}function Gi(s,t,e){return(1-e)*s+e*t}function ps(s){return(s&s-1)===0&&s!==0}function wr(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function li(s,t){switch(t.constructor){case Float32Array:return s;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function pe(s,t){switch(t.constructor){case Float32Array:return s;case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}class Mt{constructor(t=0,e=0){Mt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*n-o*i+t.x,this.y=r*i+o*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class xe{constructor(){xe.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,n,i,r,o,a,c,l){const u=this.elements;return u[0]=t,u[1]=i,u[2]=a,u[3]=e,u[4]=r,u[5]=c,u[6]=n,u[7]=o,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,o=n[0],a=n[3],c=n[6],l=n[1],u=n[4],d=n[7],f=n[2],m=n[5],b=n[8],p=i[0],h=i[3],S=i[6],k=i[1],T=i[4],M=i[7],y=i[2],E=i[5],P=i[8];return r[0]=o*p+a*k+c*y,r[3]=o*h+a*T+c*E,r[6]=o*S+a*M+c*P,r[1]=l*p+u*k+d*y,r[4]=l*h+u*T+d*E,r[7]=l*S+u*M+d*P,r[2]=f*p+m*k+b*y,r[5]=f*h+m*T+b*E,r[8]=f*S+m*M+b*P,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],c=t[6],l=t[7],u=t[8];return e*o*u-e*a*l-n*r*u+n*a*c+i*r*l-i*o*c}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],c=t[6],l=t[7],u=t[8],d=u*o-a*l,f=a*c-u*r,m=l*r-o*c,b=e*d+n*f+i*m;if(b===0)return this.set(0,0,0,0,0,0,0,0,0);const p=1/b;return t[0]=d*p,t[1]=(i*l-u*n)*p,t[2]=(a*n-i*o)*p,t[3]=f*p,t[4]=(u*e-i*c)*p,t[5]=(i*r-a*e)*p,t[6]=m*p,t[7]=(n*c-l*e)*p,t[8]=(o*e-n*r)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,o,a){const c=Math.cos(r),l=Math.sin(r);return this.set(n*c,n*l,-n*(c*o+l*a)+o+t,-i*l,i*c,-i*(-l*o+c*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(ji.makeScale(t,e)),this}rotate(t){return this.premultiply(ji.makeRotation(-t)),this}translate(t,e){return this.premultiply(ji.makeTranslation(t,e)),this}makeTranslation(t,e){return this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const ji=new xe;function oa(s){for(let t=s.length-1;t>=0;--t)if(s[t]>=65535)return!0;return!1}function ni(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function fn(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function Ii(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}const zi={[Ce]:{[ei]:fn},[ei]:{[Ce]:Ii}},ae={legacyMode:!0,get workingColorSpace(){return ei},set workingColorSpace(s){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(s,t,e){if(this.legacyMode||t===e||!t||!e)return s;if(zi[t]&&zi[t][e]!==void 0){const n=zi[t][e];return s.r=n(s.r),s.g=n(s.g),s.b=n(s.b),s}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(s,t){return this.convert(s,this.workingColorSpace,t)},toWorkingColorSpace:function(s,t){return this.convert(s,t,this.workingColorSpace)}},la={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Gt={r:0,g:0,b:0},Te={h:0,s:0,l:0},ci={h:0,s:0,l:0};function Qi(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+(t-s)*6*e:e<1/2?t:e<2/3?s+(t-s)*6*(2/3-e):s}function ui(s,t){return t.r=s.r,t.g=s.g,t.b=s.b,t}class Vt{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Ce){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,ae.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=ae.workingColorSpace){return this.r=t,this.g=e,this.b=n,ae.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=ae.workingColorSpace){if(t=ko(t,1),e=ue(e,0,1),n=ue(n,0,1),e===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,o=2*n-r;this.r=Qi(o,r,t+1/3),this.g=Qi(o,r,t),this.b=Qi(o,r,t-1/3)}return ae.toWorkingColorSpace(this,i),this}setStyle(t,e=Ce){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,ae.toWorkingColorSpace(this,e),n(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,ae.toWorkingColorSpace(this,e),n(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const c=parseFloat(r[1])/360,l=parseFloat(r[2])/100,u=parseFloat(r[3])/100;return n(r[4]),this.setHSL(c,l,u,e)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=i[1],o=r.length;if(o===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,ae.toWorkingColorSpace(this,e),this;if(o===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,ae.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=Ce){const n=la[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=fn(t.r),this.g=fn(t.g),this.b=fn(t.b),this}copyLinearToSRGB(t){return this.r=Ii(t.r),this.g=Ii(t.g),this.b=Ii(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Ce){return ae.fromWorkingColorSpace(ui(this,Gt),t),ue(Gt.r*255,0,255)<<16^ue(Gt.g*255,0,255)<<8^ue(Gt.b*255,0,255)<<0}getHexString(t=Ce){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=ae.workingColorSpace){ae.fromWorkingColorSpace(ui(this,Gt),e);const n=Gt.r,i=Gt.g,r=Gt.b,o=Math.max(n,i,r),a=Math.min(n,i,r);let c,l;const u=(a+o)/2;if(a===o)c=0,l=0;else{const d=o-a;switch(l=u<=.5?d/(o+a):d/(2-o-a),o){case n:c=(i-r)/d+(i<r?6:0);break;case i:c=(r-n)/d+2;break;case r:c=(n-i)/d+4;break}c/=6}return t.h=c,t.s=l,t.l=u,t}getRGB(t,e=ae.workingColorSpace){return ae.fromWorkingColorSpace(ui(this,Gt),e),t.r=Gt.r,t.g=Gt.g,t.b=Gt.b,t}getStyle(t=Ce){return ae.fromWorkingColorSpace(ui(this,Gt),t),t!==Ce?`color(${t} ${Gt.r} ${Gt.g} ${Gt.b})`:`rgb(${Gt.r*255|0},${Gt.g*255|0},${Gt.b*255|0})`}offsetHSL(t,e,n){return this.getHSL(Te),Te.h+=t,Te.s+=e,Te.l+=n,this.setHSL(Te.h,Te.s,Te.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Te),t.getHSL(ci);const n=Gi(Te.h,ci.h,e),i=Gi(Te.s,ci.s,e),r=Gi(Te.l,ci.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}Vt.NAMES=la;let vn;class ca{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{vn===void 0&&(vn=ni("canvas")),vn.width=t.width,vn.height=t.height;const n=vn.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=vn}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=ni("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let o=0;o<r.length;o++)r[o]=fn(r[o]/255)*255;return n.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(fn(e[n]/255)*255):e[n]=fn(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class ua{constructor(t=null){this.isSource=!0,this.uuid=ii(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(Zi(i[o].image)):r.push(Zi(i[o]))}else r=Zi(i);n.url=r}return e||(t.images[this.uuid]=n),n}}function Zi(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?ca.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let wo=0;class he extends bn{constructor(t=he.DEFAULT_IMAGE,e=he.DEFAULT_MAPPING,n=we,i=we,r=ve,o=Pi,a=Ee,c=pn,l=he.DEFAULT_ANISOTROPY,u=mn){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:wo++}),this.uuid=ii(),this.name="",this.source=new ua(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=c,this.offset=new Mt(0,0),this.repeat=new Mt(1,1),this.center=new Mt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xe,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ra)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case $n:t.x=t.x-Math.floor(t.x);break;case we:t.x=t.x<0?0:1;break;case Tr:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case $n:t.y=t.y-Math.floor(t.y);break;case we:t.y=t.y<0?0:1;break;case Tr:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}he.DEFAULT_IMAGE=null;he.DEFAULT_MAPPING=ra;he.DEFAULT_ANISOTROPY=1;class te{constructor(t=0,e=0,n=0,i=1){te.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,o=t.elements;return this.x=o[0]*e+o[4]*n+o[8]*i+o[12]*r,this.y=o[1]*e+o[5]*n+o[9]*i+o[13]*r,this.z=o[2]*e+o[6]*n+o[10]*i+o[14]*r,this.w=o[3]*e+o[7]*n+o[11]*i+o[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const c=t.elements,l=c[0],u=c[4],d=c[8],f=c[1],m=c[5],b=c[9],p=c[2],h=c[6],S=c[10];if(Math.abs(u-f)<.01&&Math.abs(d-p)<.01&&Math.abs(b-h)<.01){if(Math.abs(u+f)<.1&&Math.abs(d+p)<.1&&Math.abs(b+h)<.1&&Math.abs(l+m+S-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const T=(l+1)/2,M=(m+1)/2,y=(S+1)/2,E=(u+f)/4,P=(d+p)/4,g=(b+h)/4;return T>M&&T>y?T<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(T),i=E/n,r=P/n):M>y?M<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(M),n=E/i,r=g/i):y<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(y),n=P/r,i=g/r),this.set(n,i,r,e),this}let k=Math.sqrt((h-b)*(h-b)+(d-p)*(d-p)+(f-u)*(f-u));return Math.abs(k)<.001&&(k=1),this.x=(h-b)/k,this.y=(d-p)/k,this.z=(f-u)/k,this.w=Math.acos((l+m+S-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class gn extends bn{constructor(t=1,e=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new te(0,0,t,e),this.scissorTest=!1,this.viewport=new te(0,0,t,e);const i={width:t,height:e,depth:1};this.texture=new he(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:ve,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new ua(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ha extends he{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=ce,this.minFilter=ce,this.wrapR=we,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Eo extends he{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=ce,this.minFilter=ce,this.wrapR=we,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Sn{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,o,a){let c=n[i+0],l=n[i+1],u=n[i+2],d=n[i+3];const f=r[o+0],m=r[o+1],b=r[o+2],p=r[o+3];if(a===0){t[e+0]=c,t[e+1]=l,t[e+2]=u,t[e+3]=d;return}if(a===1){t[e+0]=f,t[e+1]=m,t[e+2]=b,t[e+3]=p;return}if(d!==p||c!==f||l!==m||u!==b){let h=1-a;const S=c*f+l*m+u*b+d*p,k=S>=0?1:-1,T=1-S*S;if(T>Number.EPSILON){const y=Math.sqrt(T),E=Math.atan2(y,S*k);h=Math.sin(h*E)/y,a=Math.sin(a*E)/y}const M=a*k;if(c=c*h+f*M,l=l*h+m*M,u=u*h+b*M,d=d*h+p*M,h===1-a){const y=1/Math.sqrt(c*c+l*l+u*u+d*d);c*=y,l*=y,u*=y,d*=y}}t[e]=c,t[e+1]=l,t[e+2]=u,t[e+3]=d}static multiplyQuaternionsFlat(t,e,n,i,r,o){const a=n[i],c=n[i+1],l=n[i+2],u=n[i+3],d=r[o],f=r[o+1],m=r[o+2],b=r[o+3];return t[e]=a*b+u*d+c*m-l*f,t[e+1]=c*b+u*f+l*d-a*m,t[e+2]=l*b+u*m+a*f-c*d,t[e+3]=u*b-a*d-c*f-l*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){const n=t._x,i=t._y,r=t._z,o=t._order,a=Math.cos,c=Math.sin,l=a(n/2),u=a(i/2),d=a(r/2),f=c(n/2),m=c(i/2),b=c(r/2);switch(o){case"XYZ":this._x=f*u*d+l*m*b,this._y=l*m*d-f*u*b,this._z=l*u*b+f*m*d,this._w=l*u*d-f*m*b;break;case"YXZ":this._x=f*u*d+l*m*b,this._y=l*m*d-f*u*b,this._z=l*u*b-f*m*d,this._w=l*u*d+f*m*b;break;case"ZXY":this._x=f*u*d-l*m*b,this._y=l*m*d+f*u*b,this._z=l*u*b+f*m*d,this._w=l*u*d-f*m*b;break;case"ZYX":this._x=f*u*d-l*m*b,this._y=l*m*d+f*u*b,this._z=l*u*b-f*m*d,this._w=l*u*d+f*m*b;break;case"YZX":this._x=f*u*d+l*m*b,this._y=l*m*d+f*u*b,this._z=l*u*b-f*m*d,this._w=l*u*d-f*m*b;break;case"XZY":this._x=f*u*d-l*m*b,this._y=l*m*d-f*u*b,this._z=l*u*b+f*m*d,this._w=l*u*d+f*m*b;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],o=e[1],a=e[5],c=e[9],l=e[2],u=e[6],d=e[10],f=n+a+d;if(f>0){const m=.5/Math.sqrt(f+1);this._w=.25/m,this._x=(u-c)*m,this._y=(r-l)*m,this._z=(o-i)*m}else if(n>a&&n>d){const m=2*Math.sqrt(1+n-a-d);this._w=(u-c)/m,this._x=.25*m,this._y=(i+o)/m,this._z=(r+l)/m}else if(a>d){const m=2*Math.sqrt(1+a-n-d);this._w=(r-l)/m,this._x=(i+o)/m,this._y=.25*m,this._z=(c+u)/m}else{const m=2*Math.sqrt(1+d-n-a);this._w=(o-i)/m,this._x=(r+l)/m,this._y=(c+u)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ue(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,o=t._w,a=e._x,c=e._y,l=e._z,u=e._w;return this._x=n*u+o*a+i*l-r*c,this._y=i*u+o*c+r*a-n*l,this._z=r*u+o*l+n*c-i*a,this._w=o*u-n*a-i*c-r*l,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,r=this._z,o=this._w;let a=o*t._w+n*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=n,this._y=i,this._z=r,this;const c=1-a*a;if(c<=Number.EPSILON){const m=1-e;return this._w=m*o+e*this._w,this._x=m*n+e*this._x,this._y=m*i+e*this._y,this._z=m*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(c),u=Math.atan2(l,a),d=Math.sin((1-e)*u)/l,f=Math.sin(e*u)/l;return this._w=o*d+this._w*f,this._x=n*d+this._x*f,this._y=i*d+this._y*f,this._z=r*d+this._z*f,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(r),n*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class N{constructor(t=0,e=0,n=0){N.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(ms.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ms.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,o=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*o,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*o,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*o,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,o=t.y,a=t.z,c=t.w,l=c*e+o*i-a*n,u=c*n+a*e-r*i,d=c*i+r*n-o*e,f=-r*e-o*n-a*i;return this.x=l*c+f*-r+u*-a-d*-o,this.y=u*c+f*-o+d*-r-l*-a,this.z=d*c+f*-a+l*-o-u*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,o=e.x,a=e.y,c=e.z;return this.x=i*c-r*a,this.y=r*o-n*c,this.z=n*a-i*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Yi.copy(this).projectOnVector(t),this.sub(Yi)}reflect(t){return this.sub(Yi.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ue(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Yi=new N,ms=new Sn;class ri{constructor(t=new N(1/0,1/0,1/0),e=new N(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let c=0,l=t.length;c<l;c+=3){const u=t[c],d=t[c+1],f=t[c+2];u<e&&(e=u),d<n&&(n=d),f<i&&(i=f),u>r&&(r=u),d>o&&(o=d),f>a&&(a=f)}return this.min.set(e,n,i),this.max.set(r,o,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let c=0,l=t.count;c<l;c++){const u=t.getX(c),d=t.getY(c),f=t.getZ(c);u<e&&(e=u),d<n&&(n=d),f<i&&(i=f),u>r&&(r=u),d>o&&(o=d),f>a&&(a=f)}return this.min.set(e,n,i),this.max.set(r,o,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=rn.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0)if(e&&n.attributes!=null&&n.attributes.position!==void 0){const r=n.attributes.position;for(let o=0,a=r.count;o<a;o++)rn.fromBufferAttribute(r,o).applyMatrix4(t.matrixWorld),this.expandByPoint(rn)}else n.boundingBox===null&&n.computeBoundingBox(),Xi.copy(n.boundingBox),Xi.applyMatrix4(t.matrixWorld),this.union(Xi);const i=t.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,rn),rn.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(jn),hi.subVectors(this.max,jn),Mn.subVectors(t.a,jn),Tn.subVectors(t.b,jn),Un.subVectors(t.c,jn),We.subVectors(Tn,Mn),qe.subVectors(Un,Tn),sn.subVectors(Mn,Un);let e=[0,-We.z,We.y,0,-qe.z,qe.y,0,-sn.z,sn.y,We.z,0,-We.x,qe.z,0,-qe.x,sn.z,0,-sn.x,-We.y,We.x,0,-qe.y,qe.x,0,-sn.y,sn.x,0];return!$i(e,Mn,Tn,Un,hi)||(e=[1,0,0,0,1,0,0,0,1],!$i(e,Mn,Tn,Un,hi))?!1:(di.crossVectors(We,qe),e=[di.x,di.y,di.z],$i(e,Mn,Tn,Un,hi))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return rn.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(rn).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(De[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),De[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),De[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),De[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),De[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),De[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),De[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),De[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(De),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const De=[new N,new N,new N,new N,new N,new N,new N,new N],rn=new N,Xi=new ri,Mn=new N,Tn=new N,Un=new N,We=new N,qe=new N,sn=new N,jn=new N,hi=new N,di=new N,an=new N;function $i(s,t,e,n,i){for(let r=0,o=s.length-3;r<=o;r+=3){an.fromArray(s,r);const a=i.x*Math.abs(an.x)+i.y*Math.abs(an.y)+i.z*Math.abs(an.z),c=t.dot(an),l=e.dot(an),u=n.dot(an);if(Math.max(-Math.max(c,l,u),Math.min(c,l,u))>a)return!1}return!0}const Co=new ri,zn=new N,tr=new N;class Ir{constructor(t=new N,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Co.setFromPoints(t).getCenter(n);let i=0;for(let r=0,o=t.length;r<o;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;zn.subVectors(t,this.center);const e=zn.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.addScaledVector(zn,i/n),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(tr.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(zn.copy(t.center).add(tr)),this.expandByPoint(zn.copy(t.center).sub(tr))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Ve=new N,er=new N,fi=new N,Ge=new N,nr=new N,pi=new N,ir=new N;class Io{constructor(t=new N,e=new N(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Ve)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Ve.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Ve.copy(this.direction).multiplyScalar(e).add(this.origin),Ve.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){er.copy(t).add(e).multiplyScalar(.5),fi.copy(e).sub(t).normalize(),Ge.copy(this.origin).sub(er);const r=t.distanceTo(e)*.5,o=-this.direction.dot(fi),a=Ge.dot(this.direction),c=-Ge.dot(fi),l=Ge.lengthSq(),u=Math.abs(1-o*o);let d,f,m,b;if(u>0)if(d=o*c-a,f=o*a-c,b=r*u,d>=0)if(f>=-b)if(f<=b){const p=1/u;d*=p,f*=p,m=d*(d+o*f+2*a)+f*(o*d+f+2*c)+l}else f=r,d=Math.max(0,-(o*f+a)),m=-d*d+f*(f+2*c)+l;else f=-r,d=Math.max(0,-(o*f+a)),m=-d*d+f*(f+2*c)+l;else f<=-b?(d=Math.max(0,-(-o*r+a)),f=d>0?-r:Math.min(Math.max(-r,-c),r),m=-d*d+f*(f+2*c)+l):f<=b?(d=0,f=Math.min(Math.max(-r,-c),r),m=f*(f+2*c)+l):(d=Math.max(0,-(o*r+a)),f=d>0?r:Math.min(Math.max(-r,-c),r),m=-d*d+f*(f+2*c)+l);else f=o>0?-r:r,d=Math.max(0,-(o*f+a)),m=-d*d+f*(f+2*c)+l;return n&&n.copy(this.direction).multiplyScalar(d).add(this.origin),i&&i.copy(fi).multiplyScalar(f).add(er),m}intersectSphere(t,e){Ve.subVectors(t.center,this.origin);const n=Ve.dot(this.direction),i=Ve.dot(Ve)-n*n,r=t.radius*t.radius;if(i>r)return null;const o=Math.sqrt(r-i),a=n-o,c=n+o;return a<0&&c<0?null:a<0?this.at(c,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,o,a,c;const l=1/this.direction.x,u=1/this.direction.y,d=1/this.direction.z,f=this.origin;return l>=0?(n=(t.min.x-f.x)*l,i=(t.max.x-f.x)*l):(n=(t.max.x-f.x)*l,i=(t.min.x-f.x)*l),u>=0?(r=(t.min.y-f.y)*u,o=(t.max.y-f.y)*u):(r=(t.max.y-f.y)*u,o=(t.min.y-f.y)*u),n>o||r>i||((r>n||isNaN(n))&&(n=r),(o<i||isNaN(i))&&(i=o),d>=0?(a=(t.min.z-f.z)*d,c=(t.max.z-f.z)*d):(a=(t.max.z-f.z)*d,c=(t.min.z-f.z)*d),n>c||a>i)||((a>n||n!==n)&&(n=a),(c<i||i!==i)&&(i=c),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,Ve)!==null}intersectTriangle(t,e,n,i,r){nr.subVectors(e,t),pi.subVectors(n,t),ir.crossVectors(nr,pi);let o=this.direction.dot(ir),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Ge.subVectors(this.origin,t);const c=a*this.direction.dot(pi.crossVectors(Ge,pi));if(c<0)return null;const l=a*this.direction.dot(nr.cross(Ge));if(l<0||c+l>o)return null;const u=-a*Ge.dot(ir);return u<0?null:this.at(u/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class jt{constructor(){jt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,n,i,r,o,a,c,l,u,d,f,m,b,p,h){const S=this.elements;return S[0]=t,S[4]=e,S[8]=n,S[12]=i,S[1]=r,S[5]=o,S[9]=a,S[13]=c,S[2]=l,S[6]=u,S[10]=d,S[14]=f,S[3]=m,S[7]=b,S[11]=p,S[15]=h,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new jt().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/kn.setFromMatrixColumn(t,0).length(),r=1/kn.setFromMatrixColumn(t,1).length(),o=1/kn.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*o,e[9]=n[9]*o,e[10]=n[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,r=t.z,o=Math.cos(n),a=Math.sin(n),c=Math.cos(i),l=Math.sin(i),u=Math.cos(r),d=Math.sin(r);if(t.order==="XYZ"){const f=o*u,m=o*d,b=a*u,p=a*d;e[0]=c*u,e[4]=-c*d,e[8]=l,e[1]=m+b*l,e[5]=f-p*l,e[9]=-a*c,e[2]=p-f*l,e[6]=b+m*l,e[10]=o*c}else if(t.order==="YXZ"){const f=c*u,m=c*d,b=l*u,p=l*d;e[0]=f+p*a,e[4]=b*a-m,e[8]=o*l,e[1]=o*d,e[5]=o*u,e[9]=-a,e[2]=m*a-b,e[6]=p+f*a,e[10]=o*c}else if(t.order==="ZXY"){const f=c*u,m=c*d,b=l*u,p=l*d;e[0]=f-p*a,e[4]=-o*d,e[8]=b+m*a,e[1]=m+b*a,e[5]=o*u,e[9]=p-f*a,e[2]=-o*l,e[6]=a,e[10]=o*c}else if(t.order==="ZYX"){const f=o*u,m=o*d,b=a*u,p=a*d;e[0]=c*u,e[4]=b*l-m,e[8]=f*l+p,e[1]=c*d,e[5]=p*l+f,e[9]=m*l-b,e[2]=-l,e[6]=a*c,e[10]=o*c}else if(t.order==="YZX"){const f=o*c,m=o*l,b=a*c,p=a*l;e[0]=c*u,e[4]=p-f*d,e[8]=b*d+m,e[1]=d,e[5]=o*u,e[9]=-a*u,e[2]=-l*u,e[6]=m*d+b,e[10]=f-p*d}else if(t.order==="XZY"){const f=o*c,m=o*l,b=a*c,p=a*l;e[0]=c*u,e[4]=-d,e[8]=l*u,e[1]=f*d+p,e[5]=o*u,e[9]=m*d-b,e[2]=b*d-m,e[6]=a*u,e[10]=p*d+f}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Lo,t,Ro)}lookAt(t,e,n){const i=this.elements;return me.subVectors(t,e),me.lengthSq()===0&&(me.z=1),me.normalize(),je.crossVectors(n,me),je.lengthSq()===0&&(Math.abs(n.z)===1?me.x+=1e-4:me.z+=1e-4,me.normalize(),je.crossVectors(n,me)),je.normalize(),mi.crossVectors(me,je),i[0]=je.x,i[4]=mi.x,i[8]=me.x,i[1]=je.y,i[5]=mi.y,i[9]=me.y,i[2]=je.z,i[6]=mi.z,i[10]=me.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,o=n[0],a=n[4],c=n[8],l=n[12],u=n[1],d=n[5],f=n[9],m=n[13],b=n[2],p=n[6],h=n[10],S=n[14],k=n[3],T=n[7],M=n[11],y=n[15],E=i[0],P=i[4],g=i[8],w=i[12],L=i[1],G=i[5],rt=i[9],V=i[13],F=i[2],j=i[6],Z=i[10],z=i[14],q=i[3],et=i[7],X=i[11],K=i[15];return r[0]=o*E+a*L+c*F+l*q,r[4]=o*P+a*G+c*j+l*et,r[8]=o*g+a*rt+c*Z+l*X,r[12]=o*w+a*V+c*z+l*K,r[1]=u*E+d*L+f*F+m*q,r[5]=u*P+d*G+f*j+m*et,r[9]=u*g+d*rt+f*Z+m*X,r[13]=u*w+d*V+f*z+m*K,r[2]=b*E+p*L+h*F+S*q,r[6]=b*P+p*G+h*j+S*et,r[10]=b*g+p*rt+h*Z+S*X,r[14]=b*w+p*V+h*z+S*K,r[3]=k*E+T*L+M*F+y*q,r[7]=k*P+T*G+M*j+y*et,r[11]=k*g+T*rt+M*Z+y*X,r[15]=k*w+T*V+M*z+y*K,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],o=t[1],a=t[5],c=t[9],l=t[13],u=t[2],d=t[6],f=t[10],m=t[14],b=t[3],p=t[7],h=t[11],S=t[15];return b*(+r*c*d-i*l*d-r*a*f+n*l*f+i*a*m-n*c*m)+p*(+e*c*m-e*l*f+r*o*f-i*o*m+i*l*u-r*c*u)+h*(+e*l*d-e*a*m-r*o*d+n*o*m+r*a*u-n*l*u)+S*(-i*a*u-e*c*d+e*a*f+i*o*d-n*o*f+n*c*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],o=t[4],a=t[5],c=t[6],l=t[7],u=t[8],d=t[9],f=t[10],m=t[11],b=t[12],p=t[13],h=t[14],S=t[15],k=d*h*l-p*f*l+p*c*m-a*h*m-d*c*S+a*f*S,T=b*f*l-u*h*l-b*c*m+o*h*m+u*c*S-o*f*S,M=u*p*l-b*d*l+b*a*m-o*p*m-u*a*S+o*d*S,y=b*d*c-u*p*c-b*a*f+o*p*f+u*a*h-o*d*h,E=e*k+n*T+i*M+r*y;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const P=1/E;return t[0]=k*P,t[1]=(p*f*r-d*h*r-p*i*m+n*h*m+d*i*S-n*f*S)*P,t[2]=(a*h*r-p*c*r+p*i*l-n*h*l-a*i*S+n*c*S)*P,t[3]=(d*c*r-a*f*r-d*i*l+n*f*l+a*i*m-n*c*m)*P,t[4]=T*P,t[5]=(u*h*r-b*f*r+b*i*m-e*h*m-u*i*S+e*f*S)*P,t[6]=(b*c*r-o*h*r-b*i*l+e*h*l+o*i*S-e*c*S)*P,t[7]=(o*f*r-u*c*r+u*i*l-e*f*l-o*i*m+e*c*m)*P,t[8]=M*P,t[9]=(b*d*r-u*p*r-b*n*m+e*p*m+u*n*S-e*d*S)*P,t[10]=(o*p*r-b*a*r+b*n*l-e*p*l-o*n*S+e*a*S)*P,t[11]=(u*a*r-o*d*r-u*n*l+e*d*l+o*n*m-e*a*m)*P,t[12]=y*P,t[13]=(u*p*i-b*d*i+b*n*f-e*p*f-u*n*h+e*d*h)*P,t[14]=(b*a*i-o*p*i-b*n*c+e*p*c+o*n*h-e*a*h)*P,t[15]=(o*d*i-u*a*i+u*n*c-e*d*c-o*n*f+e*a*f)*P,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,o=t.x,a=t.y,c=t.z,l=r*o,u=r*a;return this.set(l*o+n,l*a-i*c,l*c+i*a,0,l*a+i*c,u*a+n,u*c-i*o,0,l*c-i*a,u*c+i*o,r*c*c+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,o){return this.set(1,n,r,0,t,1,o,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,o=e._y,a=e._z,c=e._w,l=r+r,u=o+o,d=a+a,f=r*l,m=r*u,b=r*d,p=o*u,h=o*d,S=a*d,k=c*l,T=c*u,M=c*d,y=n.x,E=n.y,P=n.z;return i[0]=(1-(p+S))*y,i[1]=(m+M)*y,i[2]=(b-T)*y,i[3]=0,i[4]=(m-M)*E,i[5]=(1-(f+S))*E,i[6]=(h+k)*E,i[7]=0,i[8]=(b+T)*P,i[9]=(h-k)*P,i[10]=(1-(f+p))*P,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=kn.set(i[0],i[1],i[2]).length();const o=kn.set(i[4],i[5],i[6]).length(),a=kn.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Ue.copy(this);const l=1/r,u=1/o,d=1/a;return Ue.elements[0]*=l,Ue.elements[1]*=l,Ue.elements[2]*=l,Ue.elements[4]*=u,Ue.elements[5]*=u,Ue.elements[6]*=u,Ue.elements[8]*=d,Ue.elements[9]*=d,Ue.elements[10]*=d,e.setFromRotationMatrix(Ue),n.x=r,n.y=o,n.z=a,this}makePerspective(t,e,n,i,r,o){const a=this.elements,c=2*r/(e-t),l=2*r/(n-i),u=(e+t)/(e-t),d=(n+i)/(n-i),f=-(o+r)/(o-r),m=-2*o*r/(o-r);return a[0]=c,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=l,a[9]=d,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=m,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,o){const a=this.elements,c=1/(e-t),l=1/(n-i),u=1/(o-r),d=(e+t)*c,f=(n+i)*l,m=(o+r)*u;return a[0]=2*c,a[4]=0,a[8]=0,a[12]=-d,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-m,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const kn=new N,Ue=new jt,Lo=new N(0,0,0),Ro=new N(1,1,1),je=new N,mi=new N,me=new N,gs=new jt,Ss=new Sn;class si{constructor(t=0,e=0,n=0,i=si.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],o=i[4],a=i[8],c=i[1],l=i[5],u=i[9],d=i[2],f=i[6],m=i[10];switch(e){case"XYZ":this._y=Math.asin(ue(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,m),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(f,l),this._z=0);break;case"YXZ":this._x=Math.asin(-ue(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,m),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-d,r),this._z=0);break;case"ZXY":this._x=Math.asin(ue(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-o,l)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-ue(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,m),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-o,l));break;case"YZX":this._z=Math.asin(ue(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-d,r)):(this._x=0,this._y=Math.atan2(a,m));break;case"XZY":this._z=Math.asin(-ue(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,l),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-u,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return gs.makeRotationFromQuaternion(t),this.setFromRotationMatrix(gs,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Ss.setFromEuler(this),this.setFromQuaternion(Ss,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}si.DefaultOrder="XYZ";si.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class da{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let Po=0;const xs=new N,wn=new Sn,Ke=new jt,gi=new N,Qn=new N,Fo=new N,No=new Sn,bs=new N(1,0,0),ys=new N(0,1,0),As=new N(0,0,1),Do={type:"added"},vs={type:"removed"};class ie extends bn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Po++}),this.uuid=ii(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ie.DefaultUp.clone();const t=new N,e=new si,n=new Sn,i=new N(1,1,1);function r(){n.setFromEuler(e,!1)}function o(){e.setFromQuaternion(n,void 0,!1)}e._onChange(r),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new jt},normalMatrix:{value:new xe}}),this.matrix=new jt,this.matrixWorld=new jt,this.matrixAutoUpdate=ie.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=ie.DefaultMatrixWorldAutoUpdate,this.layers=new da,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return wn.setFromAxisAngle(t,e),this.quaternion.multiply(wn),this}rotateOnWorldAxis(t,e){return wn.setFromAxisAngle(t,e),this.quaternion.premultiply(wn),this}rotateX(t){return this.rotateOnAxis(bs,t)}rotateY(t){return this.rotateOnAxis(ys,t)}rotateZ(t){return this.rotateOnAxis(As,t)}translateOnAxis(t,e){return xs.copy(t).applyQuaternion(this.quaternion),this.position.add(xs.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(bs,t)}translateY(t){return this.translateOnAxis(ys,t)}translateZ(t){return this.translateOnAxis(As,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Ke.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?gi.copy(t):gi.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Qn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ke.lookAt(Qn,gi,this.up):Ke.lookAt(gi,Qn,this.up),this.quaternion.setFromRotationMatrix(Ke),i&&(Ke.extractRotation(i.matrixWorld),wn.setFromRotationMatrix(Ke),this.quaternion.premultiply(wn.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Do)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(vs)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(vs)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Ke.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Ke.multiply(t.parent.matrixWorld)),t.applyMatrix4(Ke),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(t,e);if(o!==void 0)return o}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qn,t,Fo),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qn,No,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++){const r=e[n];(r.matrixWorldAutoUpdate===!0||t===!0)&&r.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++){const a=i[r];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(a,c){return a[c.uuid]===void 0&&(a[c.uuid]=c.toJSON(t)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const c=a.shapes;if(Array.isArray(c))for(let l=0,u=c.length;l<u;l++){const d=c[l];r(t.shapes,d)}else r(t.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let c=0,l=this.material.length;c<l;c++)a.push(r(t.materials,this.material[c]));i.material=a}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const c=this.animations[a];i.animations.push(r(t.animations,c))}}if(e){const a=o(t.geometries),c=o(t.materials),l=o(t.textures),u=o(t.images),d=o(t.shapes),f=o(t.skeletons),m=o(t.animations),b=o(t.nodes);a.length>0&&(n.geometries=a),c.length>0&&(n.materials=c),l.length>0&&(n.textures=l),u.length>0&&(n.images=u),d.length>0&&(n.shapes=d),f.length>0&&(n.skeletons=f),m.length>0&&(n.animations=m),b.length>0&&(n.nodes=b)}return n.object=i,n;function o(a){const c=[];for(const l in a){const u=a[l];delete u.metadata,c.push(u)}return c}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}ie.DefaultUp=new N(0,1,0);ie.DefaultMatrixAutoUpdate=!0;ie.DefaultMatrixWorldAutoUpdate=!0;const ke=new N,Oe=new N,rr=new N,Je=new N,En=new N,Cn=new N,Ms=new N,sr=new N,ar=new N,or=new N;class Be{constructor(t=new N,e=new N,n=new N){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),ke.subVectors(t,e),i.cross(ke);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){ke.subVectors(i,e),Oe.subVectors(n,e),rr.subVectors(t,e);const o=ke.dot(ke),a=ke.dot(Oe),c=ke.dot(rr),l=Oe.dot(Oe),u=Oe.dot(rr),d=o*l-a*a;if(d===0)return r.set(-2,-1,-1);const f=1/d,m=(l*c-a*u)*f,b=(o*u-a*c)*f;return r.set(1-m-b,b,m)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Je),Je.x>=0&&Je.y>=0&&Je.x+Je.y<=1}static getUV(t,e,n,i,r,o,a,c){return this.getBarycoord(t,e,n,i,Je),c.set(0,0),c.addScaledVector(r,Je.x),c.addScaledVector(o,Je.y),c.addScaledVector(a,Je.z),c}static isFrontFacing(t,e,n,i){return ke.subVectors(n,e),Oe.subVectors(t,e),ke.cross(Oe).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ke.subVectors(this.c,this.b),Oe.subVectors(this.a,this.b),ke.cross(Oe).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Be.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Be.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return Be.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return Be.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Be.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let o,a;En.subVectors(i,n),Cn.subVectors(r,n),sr.subVectors(t,n);const c=En.dot(sr),l=Cn.dot(sr);if(c<=0&&l<=0)return e.copy(n);ar.subVectors(t,i);const u=En.dot(ar),d=Cn.dot(ar);if(u>=0&&d<=u)return e.copy(i);const f=c*d-u*l;if(f<=0&&c>=0&&u<=0)return o=c/(c-u),e.copy(n).addScaledVector(En,o);or.subVectors(t,r);const m=En.dot(or),b=Cn.dot(or);if(b>=0&&m<=b)return e.copy(r);const p=m*l-c*b;if(p<=0&&l>=0&&b<=0)return a=l/(l-b),e.copy(n).addScaledVector(Cn,a);const h=u*b-m*d;if(h<=0&&d-u>=0&&m-b>=0)return Ms.subVectors(r,i),a=(d-u)/(d-u+(m-b)),e.copy(i).addScaledVector(Ms,a);const S=1/(h+p+f);return o=p*S,a=f*S,e.copy(n).addScaledVector(En,o).addScaledVector(Cn,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Vo=0;class ai extends bn{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Vo++}),this.uuid=ii(),this.name="",this.type="Material",this.blending=Kn,this.side=Jn,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=ea,this.blendDst=na,this.blendEquation=Dn,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Ar,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Uo,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Wi,this.stencilZFail=Wi,this.stencilZPass=Wi,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Kn&&(n.blending=this.blending),this.side!==Jn&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const o=[];for(const a in r){const c=r[a];delete c.metadata,o.push(c)}return o}if(e){const r=i(t.textures),o=i(t.images);r.length>0&&(n.textures=r),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class fa extends ai{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Vt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ia,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Ht=new N,Si=new Mt;class Re{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=ds,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Si.fromBufferAttribute(this,e),Si.applyMatrix3(t),this.setXY(e,Si.x,Si.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)Ht.fromBufferAttribute(this,e),Ht.applyMatrix3(t),this.setXYZ(e,Ht.x,Ht.y,Ht.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Ht.fromBufferAttribute(this,e),Ht.applyMatrix4(t),this.setXYZ(e,Ht.x,Ht.y,Ht.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Ht.fromBufferAttribute(this,e),Ht.applyNormalMatrix(t),this.setXYZ(e,Ht.x,Ht.y,Ht.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Ht.fromBufferAttribute(this,e),Ht.transformDirection(t),this.setXYZ(e,Ht.x,Ht.y,Ht.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=li(e,this.array)),e}setX(t,e){return this.normalized&&(e=pe(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=li(e,this.array)),e}setY(t,e){return this.normalized&&(e=pe(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=li(e,this.array)),e}setZ(t,e){return this.normalized&&(e=pe(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=li(e,this.array)),e}setW(t,e){return this.normalized&&(e=pe(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=pe(e,this.array),n=pe(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=pe(e,this.array),n=pe(n,this.array),i=pe(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=pe(e,this.array),n=pe(n,this.array),i=pe(i,this.array),r=pe(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==ds&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class pa extends Re{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class ma extends Re{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Pe extends Re{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Ko=0;const Ae=new jt,lr=new ie,In=new N,ge=new ri,Zn=new ri,$t=new N;class Xe extends bn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ko++}),this.uuid=ii(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(oa(t)?ma:pa)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new xe().getNormalMatrix(t);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Ae.makeRotationFromQuaternion(t),this.applyMatrix4(Ae),this}rotateX(t){return Ae.makeRotationX(t),this.applyMatrix4(Ae),this}rotateY(t){return Ae.makeRotationY(t),this.applyMatrix4(Ae),this}rotateZ(t){return Ae.makeRotationZ(t),this.applyMatrix4(Ae),this}translate(t,e,n){return Ae.makeTranslation(t,e,n),this.applyMatrix4(Ae),this}scale(t,e,n){return Ae.makeScale(t,e,n),this.applyMatrix4(Ae),this}lookAt(t){return lr.lookAt(t),lr.updateMatrix(),this.applyMatrix4(lr.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(In).negate(),this.translate(In.x,In.y,In.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Pe(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ri);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new N(-1/0,-1/0,-1/0),new N(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const r=e[n];ge.setFromBufferAttribute(r),this.morphTargetsRelative?($t.addVectors(this.boundingBox.min,ge.min),this.boundingBox.expandByPoint($t),$t.addVectors(this.boundingBox.max,ge.max),this.boundingBox.expandByPoint($t)):(this.boundingBox.expandByPoint(ge.min),this.boundingBox.expandByPoint(ge.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ir);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new N,1/0);return}if(t){const n=this.boundingSphere.center;if(ge.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const a=e[r];Zn.setFromBufferAttribute(a),this.morphTargetsRelative?($t.addVectors(ge.min,Zn.min),ge.expandByPoint($t),$t.addVectors(ge.max,Zn.max),ge.expandByPoint($t)):(ge.expandByPoint(Zn.min),ge.expandByPoint(Zn.max))}ge.getCenter(n);let i=0;for(let r=0,o=t.count;r<o;r++)$t.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared($t));if(e)for(let r=0,o=e.length;r<o;r++){const a=e[r],c=this.morphTargetsRelative;for(let l=0,u=a.count;l<u;l++)$t.fromBufferAttribute(a,l),c&&(In.fromBufferAttribute(t,l),$t.add(In)),i=Math.max(i,n.distanceToSquared($t))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,r=e.normal.array,o=e.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Re(new Float32Array(4*a),4));const c=this.getAttribute("tangent").array,l=[],u=[];for(let L=0;L<a;L++)l[L]=new N,u[L]=new N;const d=new N,f=new N,m=new N,b=new Mt,p=new Mt,h=new Mt,S=new N,k=new N;function T(L,G,rt){d.fromArray(i,L*3),f.fromArray(i,G*3),m.fromArray(i,rt*3),b.fromArray(o,L*2),p.fromArray(o,G*2),h.fromArray(o,rt*2),f.sub(d),m.sub(d),p.sub(b),h.sub(b);const V=1/(p.x*h.y-h.x*p.y);isFinite(V)&&(S.copy(f).multiplyScalar(h.y).addScaledVector(m,-p.y).multiplyScalar(V),k.copy(m).multiplyScalar(p.x).addScaledVector(f,-h.x).multiplyScalar(V),l[L].add(S),l[G].add(S),l[rt].add(S),u[L].add(k),u[G].add(k),u[rt].add(k))}let M=this.groups;M.length===0&&(M=[{start:0,count:n.length}]);for(let L=0,G=M.length;L<G;++L){const rt=M[L],V=rt.start,F=rt.count;for(let j=V,Z=V+F;j<Z;j+=3)T(n[j+0],n[j+1],n[j+2])}const y=new N,E=new N,P=new N,g=new N;function w(L){P.fromArray(r,L*3),g.copy(P);const G=l[L];y.copy(G),y.sub(P.multiplyScalar(P.dot(G))).normalize(),E.crossVectors(g,G);const V=E.dot(u[L])<0?-1:1;c[L*4]=y.x,c[L*4+1]=y.y,c[L*4+2]=y.z,c[L*4+3]=V}for(let L=0,G=M.length;L<G;++L){const rt=M[L],V=rt.start,F=rt.count;for(let j=V,Z=V+F;j<Z;j+=3)w(n[j+0]),w(n[j+1]),w(n[j+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Re(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let f=0,m=n.count;f<m;f++)n.setXYZ(f,0,0,0);const i=new N,r=new N,o=new N,a=new N,c=new N,l=new N,u=new N,d=new N;if(t)for(let f=0,m=t.count;f<m;f+=3){const b=t.getX(f+0),p=t.getX(f+1),h=t.getX(f+2);i.fromBufferAttribute(e,b),r.fromBufferAttribute(e,p),o.fromBufferAttribute(e,h),u.subVectors(o,r),d.subVectors(i,r),u.cross(d),a.fromBufferAttribute(n,b),c.fromBufferAttribute(n,p),l.fromBufferAttribute(n,h),a.add(u),c.add(u),l.add(u),n.setXYZ(b,a.x,a.y,a.z),n.setXYZ(p,c.x,c.y,c.z),n.setXYZ(h,l.x,l.y,l.z)}else for(let f=0,m=e.count;f<m;f+=3)i.fromBufferAttribute(e,f+0),r.fromBufferAttribute(e,f+1),o.fromBufferAttribute(e,f+2),u.subVectors(o,r),d.subVectors(i,r),u.cross(d),n.setXYZ(f+0,u.x,u.y,u.z),n.setXYZ(f+1,u.x,u.y,u.z),n.setXYZ(f+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)$t.fromBufferAttribute(t,e),$t.normalize(),t.setXYZ(e,$t.x,$t.y,$t.z)}toNonIndexed(){function t(a,c){const l=a.array,u=a.itemSize,d=a.normalized,f=new l.constructor(c.length*u);let m=0,b=0;for(let p=0,h=c.length;p<h;p++){a.isInterleavedBufferAttribute?m=c[p]*a.data.stride+a.offset:m=c[p]*u;for(let S=0;S<u;S++)f[b++]=l[m++]}return new Re(f,u,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Xe,n=this.index.array,i=this.attributes;for(const a in i){const c=i[a],l=t(c,n);e.setAttribute(a,l)}const r=this.morphAttributes;for(const a in r){const c=[],l=r[a];for(let u=0,d=l.length;u<d;u++){const f=l[u],m=t(f,n);c.push(m)}e.morphAttributes[a]=c}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,c=o.length;a<c;a++){const l=o[a];e.addGroup(l.start,l.count,l.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(t[l]=c[l]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const c in n){const l=n[c];t.data.attributes[c]=l.toJSON(t.data)}const i={};let r=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],u=[];for(let d=0,f=l.length;d<f;d++){const m=l[d];u.push(m.toJSON(t.data))}u.length>0&&(i[c]=u,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const l in i){const u=i[l];this.setAttribute(l,u.clone(e))}const r=t.morphAttributes;for(const l in r){const u=[],d=r[l];for(let f=0,m=d.length;f<m;f++)u.push(d[f].clone(e));this.morphAttributes[l]=u}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let l=0,u=o.length;l<u;l++){const d=o[l];this.addGroup(d.start,d.count,d.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const c=t.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ts=new jt,Ln=new Io,cr=new Ir,ze=new N,Qe=new N,Ze=new N,ur=new N,hr=new N,dr=new N,xi=new N,bi=new N,yi=new N,Ai=new Mt,vi=new Mt,Mi=new Mt,fr=new N,Ti=new N;class Le extends ie{constructor(t=new Xe,e=new fa){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),cr.copy(n.boundingSphere),cr.applyMatrix4(r),t.ray.intersectsSphere(cr)===!1)||(Ts.copy(r).invert(),Ln.copy(t.ray).applyMatrix4(Ts),n.boundingBox!==null&&Ln.intersectsBox(n.boundingBox)===!1))return;let o;const a=n.index,c=n.attributes.position,l=n.morphAttributes.position,u=n.morphTargetsRelative,d=n.attributes.uv,f=n.attributes.uv2,m=n.groups,b=n.drawRange;if(a!==null)if(Array.isArray(i))for(let p=0,h=m.length;p<h;p++){const S=m[p],k=i[S.materialIndex],T=Math.max(S.start,b.start),M=Math.min(a.count,Math.min(S.start+S.count,b.start+b.count));for(let y=T,E=M;y<E;y+=3){const P=a.getX(y),g=a.getX(y+1),w=a.getX(y+2);o=Ui(this,k,t,Ln,c,l,u,d,f,P,g,w),o&&(o.faceIndex=Math.floor(y/3),o.face.materialIndex=S.materialIndex,e.push(o))}}else{const p=Math.max(0,b.start),h=Math.min(a.count,b.start+b.count);for(let S=p,k=h;S<k;S+=3){const T=a.getX(S),M=a.getX(S+1),y=a.getX(S+2);o=Ui(this,i,t,Ln,c,l,u,d,f,T,M,y),o&&(o.faceIndex=Math.floor(S/3),e.push(o))}}else if(c!==void 0)if(Array.isArray(i))for(let p=0,h=m.length;p<h;p++){const S=m[p],k=i[S.materialIndex],T=Math.max(S.start,b.start),M=Math.min(c.count,Math.min(S.start+S.count,b.start+b.count));for(let y=T,E=M;y<E;y+=3){const P=y,g=y+1,w=y+2;o=Ui(this,k,t,Ln,c,l,u,d,f,P,g,w),o&&(o.faceIndex=Math.floor(y/3),o.face.materialIndex=S.materialIndex,e.push(o))}}else{const p=Math.max(0,b.start),h=Math.min(c.count,b.start+b.count);for(let S=p,k=h;S<k;S+=3){const T=S,M=S+1,y=S+2;o=Ui(this,i,t,Ln,c,l,u,d,f,T,M,y),o&&(o.faceIndex=Math.floor(S/3),e.push(o))}}}}function Oo(s,t,e,n,i,r,o,a){let c;if(t.side===Me?c=n.intersectTriangle(o,r,i,!0,a):c=n.intersectTriangle(i,r,o,t.side!==_e,a),c===null)return null;Ti.copy(a),Ti.applyMatrix4(s.matrixWorld);const l=e.ray.origin.distanceTo(Ti);return l<e.near||l>e.far?null:{distance:l,point:Ti.clone(),object:s}}function Ui(s,t,e,n,i,r,o,a,c,l,u,d){ze.fromBufferAttribute(i,l),Qe.fromBufferAttribute(i,u),Ze.fromBufferAttribute(i,d);const f=s.morphTargetInfluences;if(r&&f){xi.set(0,0,0),bi.set(0,0,0),yi.set(0,0,0);for(let b=0,p=r.length;b<p;b++){const h=f[b],S=r[b];h!==0&&(ur.fromBufferAttribute(S,l),hr.fromBufferAttribute(S,u),dr.fromBufferAttribute(S,d),o?(xi.addScaledVector(ur,h),bi.addScaledVector(hr,h),yi.addScaledVector(dr,h)):(xi.addScaledVector(ur.sub(ze),h),bi.addScaledVector(hr.sub(Qe),h),yi.addScaledVector(dr.sub(Ze),h)))}ze.add(xi),Qe.add(bi),Ze.add(yi)}s.isSkinnedMesh&&(s.boneTransform(l,ze),s.boneTransform(u,Qe),s.boneTransform(d,Ze));const m=Oo(s,t,e,n,ze,Qe,Ze,fr);if(m){a&&(Ai.fromBufferAttribute(a,l),vi.fromBufferAttribute(a,u),Mi.fromBufferAttribute(a,d),m.uv=Be.getUV(fr,ze,Qe,Ze,Ai,vi,Mi,new Mt)),c&&(Ai.fromBufferAttribute(c,l),vi.fromBufferAttribute(c,u),Mi.fromBufferAttribute(c,d),m.uv2=Be.getUV(fr,ze,Qe,Ze,Ai,vi,Mi,new Mt));const b={a:l,b:u,c:d,normal:new N,materialIndex:0};Be.getNormal(ze,Qe,Ze,b.normal),m.face=b}return m}class oi extends Xe{constructor(t=1,e=1,n=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const c=[],l=[],u=[],d=[];let f=0,m=0;b("z","y","x",-1,-1,n,e,t,o,r,0),b("z","y","x",1,-1,n,e,-t,o,r,1),b("x","z","y",1,1,t,n,e,i,o,2),b("x","z","y",1,-1,t,n,-e,i,o,3),b("x","y","z",1,-1,t,e,n,i,r,4),b("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(c),this.setAttribute("position",new Pe(l,3)),this.setAttribute("normal",new Pe(u,3)),this.setAttribute("uv",new Pe(d,2));function b(p,h,S,k,T,M,y,E,P,g,w){const L=M/P,G=y/g,rt=M/2,V=y/2,F=E/2,j=P+1,Z=g+1;let z=0,q=0;const et=new N;for(let X=0;X<Z;X++){const K=X*G-V;for(let _=0;_<j;_++){const Y=_*L-rt;et[p]=Y*k,et[h]=K*T,et[S]=F,l.push(et.x,et.y,et.z),et[p]=0,et[h]=0,et[S]=E>0?1:-1,u.push(et.x,et.y,et.z),d.push(_/P),d.push(1-X/g),z+=1}}for(let X=0;X<g;X++)for(let K=0;K<P;K++){const _=f+K+j*X,Y=f+K+j*(X+1),tt=f+(K+1)+j*(X+1),st=f+(K+1)+j*X;c.push(_,Y,st),c.push(Y,tt,st),q+=6}a.addGroup(m,q,w),m+=q,f+=z}}static fromJSON(t){return new oi(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Wn(s){const t={};for(const e in s){t[e]={};for(const n in s[e]){const i=s[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function oe(s){const t={};for(let e=0;e<s.length;e++){const n=Wn(s[e]);for(const i in n)t[i]=n[i]}return t}function Jo(s){const t=[];for(let e=0;e<s.length;e++)t.push(s[e].clone());return t}function ga(s){return s.getRenderTarget()===null&&s.outputEncoding===Ot?Ce:ei}const Bo={clone:Wn,merge:oe};var _o=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Ho=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class xn extends ai{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=_o,this.fragmentShader=Ho,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Wn(t.uniforms),this.uniformsGroups=Jo(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?e.uniforms[i]={type:"t",value:o.toJSON(t).uuid}:o&&o.isColor?e.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[i]={type:"m4",value:o.toArray()}:e.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class Sa extends ie{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new jt,this.projectionMatrix=new jt,this.projectionMatrixInverse=new jt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Se extends Sa{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=kr*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(qi*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return kr*2*Math.atan(Math.tan(qi*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,o){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(qi*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const c=o.fullWidth,l=o.fullHeight;r+=o.offsetX*i/c,e-=o.offsetY*n/l,i*=o.width/c,n*=o.height/l}const a=this.filmOffset;a!==0&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const Rn=-90,Pn=1;class Wo extends ie{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n;const i=new Se(Rn,Pn,t,e);i.layers=this.layers,i.up.set(0,1,0),i.lookAt(1,0,0),this.add(i);const r=new Se(Rn,Pn,t,e);r.layers=this.layers,r.up.set(0,1,0),r.lookAt(-1,0,0),this.add(r);const o=new Se(Rn,Pn,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(0,1,0),this.add(o);const a=new Se(Rn,Pn,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(0,-1,0),this.add(a);const c=new Se(Rn,Pn,t,e);c.layers=this.layers,c.up.set(0,1,0),c.lookAt(0,0,1),this.add(c);const l=new Se(Rn,Pn,t,e);l.layers=this.layers,l.up.set(0,1,0),l.lookAt(0,0,-1),this.add(l)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,o,a,c,l]=this.children,u=t.getRenderTarget(),d=t.toneMapping,f=t.xr.enabled;t.toneMapping=He,t.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,o),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,c),n.texture.generateMipmaps=m,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.toneMapping=d,t.xr.enabled=f,n.texture.needsPMREMUpdate=!0}}class xa extends he{constructor(t,e,n,i,r,o,a,c,l,u){t=t!==void 0?t:[],e=e!==void 0?e:Bn,super(t,e,n,i,r,o,a,c,l,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class qo extends gn{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new xa(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:ve}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new oi(5,5,5),r=new xn({name:"CubemapFromEquirect",uniforms:Wn(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Me,blending:Ye});r.uniforms.tEquirect.value=e;const o=new Le(i,r),a=e.minFilter;return e.minFilter===Pi&&(e.minFilter=ve),new Wo(1,10,this).update(t,o),e.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let o=0;o<6;o++)t.setRenderTarget(this,o),t.clear(e,n,i);t.setRenderTarget(r)}}const pr=new N,Go=new N,jo=new xe;class on{constructor(t=new N(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=pr.subVectors(n,e).cross(Go.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(pr),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||jo.getNormalMatrix(t),i=this.coplanarPoint(pr).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Fn=new Ir,ki=new N;class Lr{constructor(t=new on,e=new on,n=new on,i=new on,r=new on,o=new on){this.planes=[t,e,n,i,r,o]}set(t,e,n,i,r,o){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(o),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],o=n[2],a=n[3],c=n[4],l=n[5],u=n[6],d=n[7],f=n[8],m=n[9],b=n[10],p=n[11],h=n[12],S=n[13],k=n[14],T=n[15];return e[0].setComponents(a-i,d-c,p-f,T-h).normalize(),e[1].setComponents(a+i,d+c,p+f,T+h).normalize(),e[2].setComponents(a+r,d+l,p+m,T+S).normalize(),e[3].setComponents(a-r,d-l,p-m,T-S).normalize(),e[4].setComponents(a-o,d-u,p-b,T-k).normalize(),e[5].setComponents(a+o,d+u,p+b,T+k).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Fn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Fn)}intersectsSprite(t){return Fn.center.set(0,0,0),Fn.radius=.7071067811865476,Fn.applyMatrix4(t.matrixWorld),this.intersectsSphere(Fn)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(ki.x=i.normal.x>0?t.max.x:t.min.x,ki.y=i.normal.y>0?t.max.y:t.min.y,ki.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(ki)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function ba(){let s=null,t=!1,e=null,n=null;function i(r,o){e(r,o),n=s.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=s.requestAnimationFrame(i),t=!0)},stop:function(){s.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){s=r}}}function zo(s,t){const e=t.isWebGL2,n=new WeakMap;function i(l,u){const d=l.array,f=l.usage,m=s.createBuffer();s.bindBuffer(u,m),s.bufferData(u,d,f),l.onUploadCallback();let b;if(d instanceof Float32Array)b=5126;else if(d instanceof Uint16Array)if(l.isFloat16BufferAttribute)if(e)b=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else b=5123;else if(d instanceof Int16Array)b=5122;else if(d instanceof Uint32Array)b=5125;else if(d instanceof Int32Array)b=5124;else if(d instanceof Int8Array)b=5120;else if(d instanceof Uint8Array)b=5121;else if(d instanceof Uint8ClampedArray)b=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+d);return{buffer:m,type:b,bytesPerElement:d.BYTES_PER_ELEMENT,version:l.version}}function r(l,u,d){const f=u.array,m=u.updateRange;s.bindBuffer(d,l),m.count===-1?s.bufferSubData(d,0,f):(e?s.bufferSubData(d,m.offset*f.BYTES_PER_ELEMENT,f,m.offset,m.count):s.bufferSubData(d,m.offset*f.BYTES_PER_ELEMENT,f.subarray(m.offset,m.offset+m.count)),m.count=-1),u.onUploadCallback()}function o(l){return l.isInterleavedBufferAttribute&&(l=l.data),n.get(l)}function a(l){l.isInterleavedBufferAttribute&&(l=l.data);const u=n.get(l);u&&(s.deleteBuffer(u.buffer),n.delete(l))}function c(l,u){if(l.isGLBufferAttribute){const f=n.get(l);(!f||f.version<l.version)&&n.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const d=n.get(l);d===void 0?n.set(l,i(l,u)):d.version<l.version&&(r(d.buffer,l,u),d.version=l.version)}return{get:o,remove:a,update:c}}class Fi extends Xe{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,o=e/2,a=Math.floor(n),c=Math.floor(i),l=a+1,u=c+1,d=t/a,f=e/c,m=[],b=[],p=[],h=[];for(let S=0;S<u;S++){const k=S*f-o;for(let T=0;T<l;T++){const M=T*d-r;b.push(M,-k,0),p.push(0,0,1),h.push(T/a),h.push(1-S/c)}}for(let S=0;S<c;S++)for(let k=0;k<a;k++){const T=k+l*S,M=k+l*(S+1),y=k+1+l*(S+1),E=k+1+l*S;m.push(T,M,E),m.push(M,y,E)}this.setIndex(m),this.setAttribute("position",new Pe(b,3)),this.setAttribute("normal",new Pe(p,3)),this.setAttribute("uv",new Pe(h,2))}static fromJSON(t){return new Fi(t.width,t.height,t.widthSegments,t.heightSegments)}}var Qo=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Zo=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Yo=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Xo=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,$o=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,tl=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,el="vec3 transformed = vec3( position );",nl=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,il=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,rl=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,sl=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,al=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,ol=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,ll=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,cl=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,ul=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,hl=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,dl=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,fl=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,pl=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,ml=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,gl=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Sl=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,xl=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,bl=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,yl=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Al="gl_FragColor = linearToOutputTexel( gl_FragColor );",vl=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Ml=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Tl=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Ul=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,kl=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,wl=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,El=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Cl=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Il=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Ll=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Rl=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Pl=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Fl=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Nl=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Dl=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Vl=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Kl=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,Ol=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Jl=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Bl=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,_l=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Hl=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,Wl=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ql=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Gl=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,jl=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,zl=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Ql=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Zl=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Yl=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Xl=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,$l=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,tc=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ec=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,nc=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,ic=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,rc=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,sc=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,ac=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,oc=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,lc=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,cc=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,uc=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,hc=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,dc=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,fc=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,pc=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,mc=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,gc=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Sc=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,xc=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,bc=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,yc=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Ac=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,vc=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Mc=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Tc=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Uc=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,kc=`#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,wc=`#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Ec=`#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Cc=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Ic=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Lc=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,Rc=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Pc=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Fc=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Nc=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Dc=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Vc=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Kc=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,Oc=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Jc=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Bc=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,_c=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Hc=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Wc=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,qc=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,Gc=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const jc=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,zc=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Qc=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Zc=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Yc=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Xc=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,$c=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,tu=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,eu=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,nu=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,iu=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,ru=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,su=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,au=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,ou=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,lu=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cu=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,uu=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hu=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,du=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fu=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,pu=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,mu=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gu=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Su=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,xu=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bu=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,yu=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Au=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,vu=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Mu=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Tu=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Uu=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,ku=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,vt={alphamap_fragment:Qo,alphamap_pars_fragment:Zo,alphatest_fragment:Yo,alphatest_pars_fragment:Xo,aomap_fragment:$o,aomap_pars_fragment:tl,begin_vertex:el,beginnormal_vertex:nl,bsdfs:il,iridescence_fragment:rl,bumpmap_pars_fragment:sl,clipping_planes_fragment:al,clipping_planes_pars_fragment:ol,clipping_planes_pars_vertex:ll,clipping_planes_vertex:cl,color_fragment:ul,color_pars_fragment:hl,color_pars_vertex:dl,color_vertex:fl,common:pl,cube_uv_reflection_fragment:ml,defaultnormal_vertex:gl,displacementmap_pars_vertex:Sl,displacementmap_vertex:xl,emissivemap_fragment:bl,emissivemap_pars_fragment:yl,encodings_fragment:Al,encodings_pars_fragment:vl,envmap_fragment:Ml,envmap_common_pars_fragment:Tl,envmap_pars_fragment:Ul,envmap_pars_vertex:kl,envmap_physical_pars_fragment:Kl,envmap_vertex:wl,fog_vertex:El,fog_pars_vertex:Cl,fog_fragment:Il,fog_pars_fragment:Ll,gradientmap_pars_fragment:Rl,lightmap_fragment:Pl,lightmap_pars_fragment:Fl,lights_lambert_fragment:Nl,lights_lambert_pars_fragment:Dl,lights_pars_begin:Vl,lights_toon_fragment:Ol,lights_toon_pars_fragment:Jl,lights_phong_fragment:Bl,lights_phong_pars_fragment:_l,lights_physical_fragment:Hl,lights_physical_pars_fragment:Wl,lights_fragment_begin:ql,lights_fragment_maps:Gl,lights_fragment_end:jl,logdepthbuf_fragment:zl,logdepthbuf_pars_fragment:Ql,logdepthbuf_pars_vertex:Zl,logdepthbuf_vertex:Yl,map_fragment:Xl,map_pars_fragment:$l,map_particle_fragment:tc,map_particle_pars_fragment:ec,metalnessmap_fragment:nc,metalnessmap_pars_fragment:ic,morphcolor_vertex:rc,morphnormal_vertex:sc,morphtarget_pars_vertex:ac,morphtarget_vertex:oc,normal_fragment_begin:lc,normal_fragment_maps:cc,normal_pars_fragment:uc,normal_pars_vertex:hc,normal_vertex:dc,normalmap_pars_fragment:fc,clearcoat_normal_fragment_begin:pc,clearcoat_normal_fragment_maps:mc,clearcoat_pars_fragment:gc,iridescence_pars_fragment:Sc,output_fragment:xc,packing:bc,premultiplied_alpha_fragment:yc,project_vertex:Ac,dithering_fragment:vc,dithering_pars_fragment:Mc,roughnessmap_fragment:Tc,roughnessmap_pars_fragment:Uc,shadowmap_pars_fragment:kc,shadowmap_pars_vertex:wc,shadowmap_vertex:Ec,shadowmask_pars_fragment:Cc,skinbase_vertex:Ic,skinning_pars_vertex:Lc,skinning_vertex:Rc,skinnormal_vertex:Pc,specularmap_fragment:Fc,specularmap_pars_fragment:Nc,tonemapping_fragment:Dc,tonemapping_pars_fragment:Vc,transmission_fragment:Kc,transmission_pars_fragment:Oc,uv_pars_fragment:Jc,uv_pars_vertex:Bc,uv_vertex:_c,uv2_pars_fragment:Hc,uv2_pars_vertex:Wc,uv2_vertex:qc,worldpos_vertex:Gc,background_vert:jc,background_frag:zc,backgroundCube_vert:Qc,backgroundCube_frag:Zc,cube_vert:Yc,cube_frag:Xc,depth_vert:$c,depth_frag:tu,distanceRGBA_vert:eu,distanceRGBA_frag:nu,equirect_vert:iu,equirect_frag:ru,linedashed_vert:su,linedashed_frag:au,meshbasic_vert:ou,meshbasic_frag:lu,meshlambert_vert:cu,meshlambert_frag:uu,meshmatcap_vert:hu,meshmatcap_frag:du,meshnormal_vert:fu,meshnormal_frag:pu,meshphong_vert:mu,meshphong_frag:gu,meshphysical_vert:Su,meshphysical_frag:xu,meshtoon_vert:bu,meshtoon_frag:yu,points_vert:Au,points_frag:vu,shadow_vert:Mu,shadow_frag:Tu,sprite_vert:Uu,sprite_frag:ku},it={common:{diffuse:{value:new Vt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new xe},uv2Transform:{value:new xe},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Mt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Vt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Vt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}},sprite:{diffuse:{value:new Vt(16777215)},opacity:{value:1},center:{value:new Mt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}}},Ie={basic:{uniforms:oe([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.fog]),vertexShader:vt.meshbasic_vert,fragmentShader:vt.meshbasic_frag},lambert:{uniforms:oe([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.fog,it.lights,{emissive:{value:new Vt(0)}}]),vertexShader:vt.meshlambert_vert,fragmentShader:vt.meshlambert_frag},phong:{uniforms:oe([it.common,it.specularmap,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.fog,it.lights,{emissive:{value:new Vt(0)},specular:{value:new Vt(1118481)},shininess:{value:30}}]),vertexShader:vt.meshphong_vert,fragmentShader:vt.meshphong_frag},standard:{uniforms:oe([it.common,it.envmap,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.roughnessmap,it.metalnessmap,it.fog,it.lights,{emissive:{value:new Vt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:vt.meshphysical_vert,fragmentShader:vt.meshphysical_frag},toon:{uniforms:oe([it.common,it.aomap,it.lightmap,it.emissivemap,it.bumpmap,it.normalmap,it.displacementmap,it.gradientmap,it.fog,it.lights,{emissive:{value:new Vt(0)}}]),vertexShader:vt.meshtoon_vert,fragmentShader:vt.meshtoon_frag},matcap:{uniforms:oe([it.common,it.bumpmap,it.normalmap,it.displacementmap,it.fog,{matcap:{value:null}}]),vertexShader:vt.meshmatcap_vert,fragmentShader:vt.meshmatcap_frag},points:{uniforms:oe([it.points,it.fog]),vertexShader:vt.points_vert,fragmentShader:vt.points_frag},dashed:{uniforms:oe([it.common,it.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:vt.linedashed_vert,fragmentShader:vt.linedashed_frag},depth:{uniforms:oe([it.common,it.displacementmap]),vertexShader:vt.depth_vert,fragmentShader:vt.depth_frag},normal:{uniforms:oe([it.common,it.bumpmap,it.normalmap,it.displacementmap,{opacity:{value:1}}]),vertexShader:vt.meshnormal_vert,fragmentShader:vt.meshnormal_frag},sprite:{uniforms:oe([it.sprite,it.fog]),vertexShader:vt.sprite_vert,fragmentShader:vt.sprite_frag},background:{uniforms:{uvTransform:{value:new xe},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:vt.background_vert,fragmentShader:vt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:vt.backgroundCube_vert,fragmentShader:vt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:vt.cube_vert,fragmentShader:vt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:vt.equirect_vert,fragmentShader:vt.equirect_frag},distanceRGBA:{uniforms:oe([it.common,it.displacementmap,{referencePosition:{value:new N},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:vt.distanceRGBA_vert,fragmentShader:vt.distanceRGBA_frag},shadow:{uniforms:oe([it.lights,it.fog,{color:{value:new Vt(0)},opacity:{value:1}}]),vertexShader:vt.shadow_vert,fragmentShader:vt.shadow_frag}};Ie.physical={uniforms:oe([Ie.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Mt(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Vt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Mt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Vt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Vt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:vt.meshphysical_vert,fragmentShader:vt.meshphysical_frag};const wi={r:0,b:0,g:0};function wu(s,t,e,n,i,r,o){const a=new Vt(0);let c=r===!0?0:1,l,u,d=null,f=0,m=null;function b(h,S){let k=!1,T=S.isScene===!0?S.background:null;T&&T.isTexture&&(T=(S.backgroundBlurriness>0?e:t).get(T));const M=s.xr,y=M.getSession&&M.getSession();y&&y.environmentBlendMode==="additive"&&(T=null),T===null?p(a,c):T&&T.isColor&&(p(T,1),k=!0),(s.autoClear||k)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),T&&(T.isCubeTexture||T.mapping===Ri)?(u===void 0&&(u=new Le(new oi(1,1,1),new xn({name:"BackgroundCubeMaterial",uniforms:Wn(Ie.backgroundCube.uniforms),vertexShader:Ie.backgroundCube.vertexShader,fragmentShader:Ie.backgroundCube.fragmentShader,side:Me,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(E,P,g){this.matrixWorld.copyPosition(g.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=T,u.material.uniforms.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=S.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=S.backgroundIntensity,(d!==T||f!==T.version||m!==s.toneMapping)&&(u.material.needsUpdate=!0,d=T,f=T.version,m=s.toneMapping),u.layers.enableAll(),h.unshift(u,u.geometry,u.material,0,0,null)):T&&T.isTexture&&(l===void 0&&(l=new Le(new Fi(2,2),new xn({name:"BackgroundMaterial",uniforms:Wn(Ie.background.uniforms),vertexShader:Ie.background.vertexShader,fragmentShader:Ie.background.fragmentShader,side:Jn,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=T,l.material.uniforms.backgroundIntensity.value=S.backgroundIntensity,T.matrixAutoUpdate===!0&&T.updateMatrix(),l.material.uniforms.uvTransform.value.copy(T.matrix),(d!==T||f!==T.version||m!==s.toneMapping)&&(l.material.needsUpdate=!0,d=T,f=T.version,m=s.toneMapping),l.layers.enableAll(),h.unshift(l,l.geometry,l.material,0,0,null))}function p(h,S){h.getRGB(wi,ga(s)),n.buffers.color.setClear(wi.r,wi.g,wi.b,S,o)}return{getClearColor:function(){return a},setClearColor:function(h,S=1){a.set(h),c=S,p(a,c)},getClearAlpha:function(){return c},setClearAlpha:function(h){c=h,p(a,c)},render:b}}function Eu(s,t,e,n){const i=s.getParameter(34921),r=n.isWebGL2?null:t.get("OES_vertex_array_object"),o=n.isWebGL2||r!==null,a={},c=h(null);let l=c,u=!1;function d(F,j,Z,z,q){let et=!1;if(o){const X=p(z,Z,j);l!==X&&(l=X,m(l.object)),et=S(F,z,Z,q),et&&k(F,z,Z,q)}else{const X=j.wireframe===!0;(l.geometry!==z.id||l.program!==Z.id||l.wireframe!==X)&&(l.geometry=z.id,l.program=Z.id,l.wireframe=X,et=!0)}q!==null&&e.update(q,34963),(et||u)&&(u=!1,g(F,j,Z,z),q!==null&&s.bindBuffer(34963,e.get(q).buffer))}function f(){return n.isWebGL2?s.createVertexArray():r.createVertexArrayOES()}function m(F){return n.isWebGL2?s.bindVertexArray(F):r.bindVertexArrayOES(F)}function b(F){return n.isWebGL2?s.deleteVertexArray(F):r.deleteVertexArrayOES(F)}function p(F,j,Z){const z=Z.wireframe===!0;let q=a[F.id];q===void 0&&(q={},a[F.id]=q);let et=q[j.id];et===void 0&&(et={},q[j.id]=et);let X=et[z];return X===void 0&&(X=h(f()),et[z]=X),X}function h(F){const j=[],Z=[],z=[];for(let q=0;q<i;q++)j[q]=0,Z[q]=0,z[q]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:j,enabledAttributes:Z,attributeDivisors:z,object:F,attributes:{},index:null}}function S(F,j,Z,z){const q=l.attributes,et=j.attributes;let X=0;const K=Z.getAttributes();for(const _ in K)if(K[_].location>=0){const tt=q[_];let st=et[_];if(st===void 0&&(_==="instanceMatrix"&&F.instanceMatrix&&(st=F.instanceMatrix),_==="instanceColor"&&F.instanceColor&&(st=F.instanceColor)),tt===void 0||tt.attribute!==st||st&&tt.data!==st.data)return!0;X++}return l.attributesNum!==X||l.index!==z}function k(F,j,Z,z){const q={},et=j.attributes;let X=0;const K=Z.getAttributes();for(const _ in K)if(K[_].location>=0){let tt=et[_];tt===void 0&&(_==="instanceMatrix"&&F.instanceMatrix&&(tt=F.instanceMatrix),_==="instanceColor"&&F.instanceColor&&(tt=F.instanceColor));const st={};st.attribute=tt,tt&&tt.data&&(st.data=tt.data),q[_]=st,X++}l.attributes=q,l.attributesNum=X,l.index=z}function T(){const F=l.newAttributes;for(let j=0,Z=F.length;j<Z;j++)F[j]=0}function M(F){y(F,0)}function y(F,j){const Z=l.newAttributes,z=l.enabledAttributes,q=l.attributeDivisors;Z[F]=1,z[F]===0&&(s.enableVertexAttribArray(F),z[F]=1),q[F]!==j&&((n.isWebGL2?s:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](F,j),q[F]=j)}function E(){const F=l.newAttributes,j=l.enabledAttributes;for(let Z=0,z=j.length;Z<z;Z++)j[Z]!==F[Z]&&(s.disableVertexAttribArray(Z),j[Z]=0)}function P(F,j,Z,z,q,et){n.isWebGL2===!0&&(Z===5124||Z===5125)?s.vertexAttribIPointer(F,j,Z,q,et):s.vertexAttribPointer(F,j,Z,z,q,et)}function g(F,j,Z,z){if(n.isWebGL2===!1&&(F.isInstancedMesh||z.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;T();const q=z.attributes,et=Z.getAttributes(),X=j.defaultAttributeValues;for(const K in et){const _=et[K];if(_.location>=0){let Y=q[K];if(Y===void 0&&(K==="instanceMatrix"&&F.instanceMatrix&&(Y=F.instanceMatrix),K==="instanceColor"&&F.instanceColor&&(Y=F.instanceColor)),Y!==void 0){const tt=Y.normalized,st=Y.itemSize,H=e.get(Y);if(H===void 0)continue;const kt=H.buffer,dt=H.type,St=H.bytesPerElement;if(Y.isInterleavedBufferAttribute){const ht=Y.data,Pt=ht.stride,At=Y.offset;if(ht.isInstancedInterleavedBuffer){for(let xt=0;xt<_.locationSize;xt++)y(_.location+xt,ht.meshPerAttribute);F.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=ht.meshPerAttribute*ht.count)}else for(let xt=0;xt<_.locationSize;xt++)M(_.location+xt);s.bindBuffer(34962,kt);for(let xt=0;xt<_.locationSize;xt++)P(_.location+xt,st/_.locationSize,dt,tt,Pt*St,(At+st/_.locationSize*xt)*St)}else{if(Y.isInstancedBufferAttribute){for(let ht=0;ht<_.locationSize;ht++)y(_.location+ht,Y.meshPerAttribute);F.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=Y.meshPerAttribute*Y.count)}else for(let ht=0;ht<_.locationSize;ht++)M(_.location+ht);s.bindBuffer(34962,kt);for(let ht=0;ht<_.locationSize;ht++)P(_.location+ht,st/_.locationSize,dt,tt,st*St,st/_.locationSize*ht*St)}}else if(X!==void 0){const tt=X[K];if(tt!==void 0)switch(tt.length){case 2:s.vertexAttrib2fv(_.location,tt);break;case 3:s.vertexAttrib3fv(_.location,tt);break;case 4:s.vertexAttrib4fv(_.location,tt);break;default:s.vertexAttrib1fv(_.location,tt)}}}}E()}function w(){rt();for(const F in a){const j=a[F];for(const Z in j){const z=j[Z];for(const q in z)b(z[q].object),delete z[q];delete j[Z]}delete a[F]}}function L(F){if(a[F.id]===void 0)return;const j=a[F.id];for(const Z in j){const z=j[Z];for(const q in z)b(z[q].object),delete z[q];delete j[Z]}delete a[F.id]}function G(F){for(const j in a){const Z=a[j];if(Z[F.id]===void 0)continue;const z=Z[F.id];for(const q in z)b(z[q].object),delete z[q];delete Z[F.id]}}function rt(){V(),u=!0,l!==c&&(l=c,m(l.object))}function V(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:d,reset:rt,resetDefaultState:V,dispose:w,releaseStatesOfGeometry:L,releaseStatesOfProgram:G,initAttributes:T,enableAttribute:M,disableUnusedAttributes:E}}function Cu(s,t,e,n){const i=n.isWebGL2;let r;function o(l){r=l}function a(l,u){s.drawArrays(r,l,u),e.update(u,r,1)}function c(l,u,d){if(d===0)return;let f,m;if(i)f=s,m="drawArraysInstanced";else if(f=t.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[m](r,l,u,d),e.update(u,r,d)}this.setMode=o,this.render=a,this.renderInstances=c}function Iu(s,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const P=t.get("EXT_texture_filter_anisotropic");n=s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(P){if(P==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";P="mediump"}return P==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const c=r(a);c!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",c,"instead."),a=c);const l=o||t.has("WEBGL_draw_buffers"),u=e.logarithmicDepthBuffer===!0,d=s.getParameter(34930),f=s.getParameter(35660),m=s.getParameter(3379),b=s.getParameter(34076),p=s.getParameter(34921),h=s.getParameter(36347),S=s.getParameter(36348),k=s.getParameter(36349),T=f>0,M=o||t.has("OES_texture_float"),y=T&&M,E=o?s.getParameter(36183):0;return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:i,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:u,maxTextures:d,maxVertexTextures:f,maxTextureSize:m,maxCubemapSize:b,maxAttributes:p,maxVertexUniforms:h,maxVaryings:S,maxFragmentUniforms:k,vertexTextures:T,floatFragmentTextures:M,floatVertexTextures:y,maxSamples:E}}function Lu(s){const t=this;let e=null,n=0,i=!1,r=!1;const o=new on,a=new xe,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(d,f,m){const b=d.length!==0||f||n!==0||i;return i=f,e=u(d,m,0),n=d.length,b},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,l()},this.setState=function(d,f,m){const b=d.clippingPlanes,p=d.clipIntersection,h=d.clipShadows,S=s.get(d);if(!i||b===null||b.length===0||r&&!h)r?u(null):l();else{const k=r?0:n,T=k*4;let M=S.clippingState||null;c.value=M,M=u(b,f,T,m);for(let y=0;y!==T;++y)M[y]=e[y];S.clippingState=M,this.numIntersection=p?this.numPlanes:0,this.numPlanes+=k}};function l(){c.value!==e&&(c.value=e,c.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function u(d,f,m,b){const p=d!==null?d.length:0;let h=null;if(p!==0){if(h=c.value,b!==!0||h===null){const S=m+p*4,k=f.matrixWorldInverse;a.getNormalMatrix(k),(h===null||h.length<S)&&(h=new Float32Array(S));for(let T=0,M=m;T!==p;++T,M+=4)o.copy(d[T]).applyMatrix4(k,a),o.normal.toArray(h,M),h[M+3]=o.constant}c.value=h,c.needsUpdate=!0}return t.numPlanes=p,t.numIntersection=0,h}}function Ru(s){let t=new WeakMap;function e(o,a){return a===vr?o.mapping=Bn:a===Mr&&(o.mapping=_n),o}function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===vr||a===Mr)if(t.has(o)){const c=t.get(o).texture;return e(c,o.mapping)}else{const c=o.image;if(c&&c.height>0){const l=new qo(c.height/2);return l.fromEquirectangularTexture(s,o),t.set(o,l),o.addEventListener("dispose",i),e(l.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const c=t.get(a);c!==void 0&&(t.delete(a),c.dispose())}function r(){t=new WeakMap}return{get:n,dispose:r}}class Pu extends Sa{constructor(t=-1,e=1,n=1,i=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,o=n+t,a=i+e,c=i-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,o=r+l*this.view.width,a-=u*this.view.offsetY,c=a-u*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const Vn=4,Us=[.125,.215,.35,.446,.526,.582],cn=20,mr=new Pu,ks=new Vt;let gr=null;const ln=(1+Math.sqrt(5))/2,Nn=1/ln,ws=[new N(1,1,1),new N(-1,1,1),new N(1,1,-1),new N(-1,1,-1),new N(0,ln,Nn),new N(0,ln,-Nn),new N(Nn,0,ln),new N(-Nn,0,ln),new N(ln,Nn,0),new N(-ln,Nn,0)];class Es{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){gr=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Ls(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Is(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(gr),t.scissorTest=!1,Ei(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===Bn||t.mapping===_n?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),gr=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:ve,minFilter:ve,generateMipmaps:!1,type:ti,format:Ee,encoding:mn,depthBuffer:!1},i=Cs(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=Cs(t,e,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Fu(r)),this._blurMaterial=Nu(r,t,e)}return i}_compileMaterial(t){const e=new Le(this._lodPlanes[0],t);this._renderer.compile(e,mr)}_sceneToCubeUV(t,e,n,i){const a=new Se(90,1,e,n),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],u=this._renderer,d=u.autoClear,f=u.toneMapping;u.getClearColor(ks),u.toneMapping=He,u.autoClear=!1;const m=new fa({name:"PMREM.Background",side:Me,depthWrite:!1,depthTest:!1}),b=new Le(new oi,m);let p=!1;const h=t.background;h?h.isColor&&(m.color.copy(h),t.background=null,p=!0):(m.color.copy(ks),p=!0);for(let S=0;S<6;S++){const k=S%3;k===0?(a.up.set(0,c[S],0),a.lookAt(l[S],0,0)):k===1?(a.up.set(0,0,c[S]),a.lookAt(0,l[S],0)):(a.up.set(0,c[S],0),a.lookAt(0,0,l[S]));const T=this._cubeSize;Ei(i,k*T,S>2?T:0,T,T),u.setRenderTarget(i),p&&u.render(b,a),u.render(t,a)}b.geometry.dispose(),b.material.dispose(),u.toneMapping=f,u.autoClear=d,t.background=h}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===Bn||t.mapping===_n;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=Ls()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Is());const r=i?this._cubemapMaterial:this._equirectMaterial,o=new Le(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=t;const c=this._cubeSize;Ei(e,0,0,3*c,2*c),n.setRenderTarget(e),n.render(o,mr)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=ws[(i-1)%ws.length];this._blur(t,i-1,i,r,o)}e.autoClear=n}_blur(t,e,n,i,r){const o=this._pingPongRenderTarget;this._halfBlur(t,o,e,n,i,"latitudinal",r),this._halfBlur(o,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,o,a){const c=this._renderer,l=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,d=new Le(this._lodPlanes[i],l),f=l.uniforms,m=this._sizeLods[n]-1,b=isFinite(r)?Math.PI/(2*m):2*Math.PI/(2*cn-1),p=r/b,h=isFinite(r)?1+Math.floor(u*p):cn;h>cn&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${h} samples when the maximum is set to ${cn}`);const S=[];let k=0;for(let P=0;P<cn;++P){const g=P/p,w=Math.exp(-g*g/2);S.push(w),P===0?k+=w:P<h&&(k+=2*w)}for(let P=0;P<S.length;P++)S[P]=S[P]/k;f.envMap.value=t.texture,f.samples.value=h,f.weights.value=S,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a);const{_lodMax:T}=this;f.dTheta.value=b,f.mipInt.value=T-n;const M=this._sizeLods[i],y=3*M*(i>T-Vn?i-T+Vn:0),E=4*(this._cubeSize-M);Ei(e,y,E,3*M,2*M),c.setRenderTarget(e),c.render(d,mr)}}function Fu(s){const t=[],e=[],n=[];let i=s;const r=s-Vn+1+Us.length;for(let o=0;o<r;o++){const a=Math.pow(2,i);e.push(a);let c=1/a;o>s-Vn?c=Us[o-s+Vn-1]:o===0&&(c=0),n.push(c);const l=1/(a-2),u=-l,d=1+l,f=[u,u,d,u,d,d,u,u,d,d,u,d],m=6,b=6,p=3,h=2,S=1,k=new Float32Array(p*b*m),T=new Float32Array(h*b*m),M=new Float32Array(S*b*m);for(let E=0;E<m;E++){const P=E%3*2/3-1,g=E>2?0:-1,w=[P,g,0,P+2/3,g,0,P+2/3,g+1,0,P,g,0,P+2/3,g+1,0,P,g+1,0];k.set(w,p*b*E),T.set(f,h*b*E);const L=[E,E,E,E,E,E];M.set(L,S*b*E)}const y=new Xe;y.setAttribute("position",new Re(k,p)),y.setAttribute("uv",new Re(T,h)),y.setAttribute("faceIndex",new Re(M,S)),t.push(y),i>Vn&&i--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function Cs(s,t,e){const n=new gn(s,t,e);return n.texture.mapping=Ri,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function Ei(s,t,e,n,i){s.viewport.set(t,e,n,i),s.scissor.set(t,e,n,i)}function Nu(s,t,e){const n=new Float32Array(cn),i=new N(0,1,0);return new xn({name:"SphericalGaussianBlur",defines:{n:cn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Rr(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Ye,depthTest:!1,depthWrite:!1})}function Is(){return new xn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Rr(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Ye,depthTest:!1,depthWrite:!1})}function Ls(){return new xn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Rr(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Ye,depthTest:!1,depthWrite:!1})}function Rr(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Du(s){let t=new WeakMap,e=null;function n(a){if(a&&a.isTexture){const c=a.mapping,l=c===vr||c===Mr,u=c===Bn||c===_n;if(l||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let d=t.get(a);return e===null&&(e=new Es(s)),d=l?e.fromEquirectangular(a,d):e.fromCubemap(a,d),t.set(a,d),d.texture}else{if(t.has(a))return t.get(a).texture;{const d=a.image;if(l&&d&&d.height>0||u&&d&&i(d)){e===null&&(e=new Es(s));const f=l?e.fromEquirectangular(a):e.fromCubemap(a);return t.set(a,f),a.addEventListener("dispose",r),f.texture}else return null}}}return a}function i(a){let c=0;const l=6;for(let u=0;u<l;u++)a[u]!==void 0&&c++;return c===l}function r(a){const c=a.target;c.removeEventListener("dispose",r);const l=t.get(c);l!==void 0&&(t.delete(c),l.dispose())}function o(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:o}}function Vu(s){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function Ku(s,t,e,n){const i={},r=new WeakMap;function o(d){const f=d.target;f.index!==null&&t.remove(f.index);for(const b in f.attributes)t.remove(f.attributes[b]);f.removeEventListener("dispose",o),delete i[f.id];const m=r.get(f);m&&(t.remove(m),r.delete(f)),n.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,e.memory.geometries--}function a(d,f){return i[f.id]===!0||(f.addEventListener("dispose",o),i[f.id]=!0,e.memory.geometries++),f}function c(d){const f=d.attributes;for(const b in f)t.update(f[b],34962);const m=d.morphAttributes;for(const b in m){const p=m[b];for(let h=0,S=p.length;h<S;h++)t.update(p[h],34962)}}function l(d){const f=[],m=d.index,b=d.attributes.position;let p=0;if(m!==null){const k=m.array;p=m.version;for(let T=0,M=k.length;T<M;T+=3){const y=k[T+0],E=k[T+1],P=k[T+2];f.push(y,E,E,P,P,y)}}else{const k=b.array;p=b.version;for(let T=0,M=k.length/3-1;T<M;T+=3){const y=T+0,E=T+1,P=T+2;f.push(y,E,E,P,P,y)}}const h=new(oa(f)?ma:pa)(f,1);h.version=p;const S=r.get(d);S&&t.remove(S),r.set(d,h)}function u(d){const f=r.get(d);if(f){const m=d.index;m!==null&&f.version<m.version&&l(d)}else l(d);return r.get(d)}return{get:a,update:c,getWireframeAttribute:u}}function Ou(s,t,e,n){const i=n.isWebGL2;let r;function o(f){r=f}let a,c;function l(f){a=f.type,c=f.bytesPerElement}function u(f,m){s.drawElements(r,m,a,f*c),e.update(m,r,1)}function d(f,m,b){if(b===0)return;let p,h;if(i)p=s,h="drawElementsInstanced";else if(p=t.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",p===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[h](r,m,a,f*c,b),e.update(m,r,b)}this.setMode=o,this.setIndex=l,this.render=u,this.renderInstances=d}function Ju(s){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,o,a){switch(e.calls++,o){case 4:e.triangles+=a*(r/3);break;case 1:e.lines+=a*(r/2);break;case 3:e.lines+=a*(r-1);break;case 2:e.lines+=a*r;break;case 0:e.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function Bu(s,t){return s[0]-t[0]}function _u(s,t){return Math.abs(t[1])-Math.abs(s[1])}function Hu(s,t,e){const n={},i=new Float32Array(8),r=new WeakMap,o=new te,a=[];for(let l=0;l<8;l++)a[l]=[l,0];function c(l,u,d,f){const m=l.morphTargetInfluences;if(t.isWebGL2===!0){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,h=p!==void 0?p.length:0;let S=r.get(u);if(S===void 0||S.count!==h){let Z=function(){F.dispose(),r.delete(u),u.removeEventListener("dispose",Z)};var b=Z;S!==void 0&&S.texture.dispose();const M=u.morphAttributes.position!==void 0,y=u.morphAttributes.normal!==void 0,E=u.morphAttributes.color!==void 0,P=u.morphAttributes.position||[],g=u.morphAttributes.normal||[],w=u.morphAttributes.color||[];let L=0;M===!0&&(L=1),y===!0&&(L=2),E===!0&&(L=3);let G=u.attributes.position.count*L,rt=1;G>t.maxTextureSize&&(rt=Math.ceil(G/t.maxTextureSize),G=t.maxTextureSize);const V=new Float32Array(G*rt*4*h),F=new ha(V,G,rt,h);F.type=hn,F.needsUpdate=!0;const j=L*4;for(let z=0;z<h;z++){const q=P[z],et=g[z],X=w[z],K=G*rt*4*z;for(let _=0;_<q.count;_++){const Y=_*j;M===!0&&(o.fromBufferAttribute(q,_),V[K+Y+0]=o.x,V[K+Y+1]=o.y,V[K+Y+2]=o.z,V[K+Y+3]=0),y===!0&&(o.fromBufferAttribute(et,_),V[K+Y+4]=o.x,V[K+Y+5]=o.y,V[K+Y+6]=o.z,V[K+Y+7]=0),E===!0&&(o.fromBufferAttribute(X,_),V[K+Y+8]=o.x,V[K+Y+9]=o.y,V[K+Y+10]=o.z,V[K+Y+11]=X.itemSize===4?o.w:1)}}S={count:h,texture:F,size:new Mt(G,rt)},r.set(u,S),u.addEventListener("dispose",Z)}let k=0;for(let M=0;M<m.length;M++)k+=m[M];const T=u.morphTargetsRelative?1:1-k;f.getUniforms().setValue(s,"morphTargetBaseInfluence",T),f.getUniforms().setValue(s,"morphTargetInfluences",m),f.getUniforms().setValue(s,"morphTargetsTexture",S.texture,e),f.getUniforms().setValue(s,"morphTargetsTextureSize",S.size)}else{const p=m===void 0?0:m.length;let h=n[u.id];if(h===void 0||h.length!==p){h=[];for(let y=0;y<p;y++)h[y]=[y,0];n[u.id]=h}for(let y=0;y<p;y++){const E=h[y];E[0]=y,E[1]=m[y]}h.sort(_u);for(let y=0;y<8;y++)y<p&&h[y][1]?(a[y][0]=h[y][0],a[y][1]=h[y][1]):(a[y][0]=Number.MAX_SAFE_INTEGER,a[y][1]=0);a.sort(Bu);const S=u.morphAttributes.position,k=u.morphAttributes.normal;let T=0;for(let y=0;y<8;y++){const E=a[y],P=E[0],g=E[1];P!==Number.MAX_SAFE_INTEGER&&g?(S&&u.getAttribute("morphTarget"+y)!==S[P]&&u.setAttribute("morphTarget"+y,S[P]),k&&u.getAttribute("morphNormal"+y)!==k[P]&&u.setAttribute("morphNormal"+y,k[P]),i[y]=g,T+=g):(S&&u.hasAttribute("morphTarget"+y)===!0&&u.deleteAttribute("morphTarget"+y),k&&u.hasAttribute("morphNormal"+y)===!0&&u.deleteAttribute("morphNormal"+y),i[y]=0)}const M=u.morphTargetsRelative?1:1-T;f.getUniforms().setValue(s,"morphTargetBaseInfluence",M),f.getUniforms().setValue(s,"morphTargetInfluences",i)}}return{update:c}}function Wu(s,t,e,n){let i=new WeakMap;function r(c){const l=n.render.frame,u=c.geometry,d=t.get(c,u);return i.get(d)!==l&&(t.update(d),i.set(d,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",a)===!1&&c.addEventListener("dispose",a),e.update(c.instanceMatrix,34962),c.instanceColor!==null&&e.update(c.instanceColor,34962)),d}function o(){i=new WeakMap}function a(c){const l=c.target;l.removeEventListener("dispose",a),e.remove(l.instanceMatrix),l.instanceColor!==null&&e.remove(l.instanceColor)}return{update:r,dispose:o}}const ya=new he,Aa=new ha,va=new Eo,Ma=new xa,Rs=[],Ps=[],Fs=new Float32Array(16),Ns=new Float32Array(9),Ds=new Float32Array(4);function qn(s,t,e){const n=s[0];if(n<=0||n>0)return s;const i=t*e;let r=Rs[i];if(r===void 0&&(r=new Float32Array(i),Rs[i]=r),t!==0){n.toArray(r,0);for(let o=1,a=0;o!==t;++o)a+=e,s[o].toArray(r,a)}return r}function zt(s,t){if(s.length!==t.length)return!1;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}function Qt(s,t){for(let e=0,n=t.length;e<n;e++)s[e]=t[e]}function Ni(s,t){let e=Ps[t];e===void 0&&(e=new Int32Array(t),Ps[t]=e);for(let n=0;n!==t;++n)e[n]=s.allocateTextureUnit();return e}function qu(s,t){const e=this.cache;e[0]!==t&&(s.uniform1f(this.addr,t),e[0]=t)}function Gu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(zt(e,t))return;s.uniform2fv(this.addr,t),Qt(e,t)}}function ju(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(s.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(zt(e,t))return;s.uniform3fv(this.addr,t),Qt(e,t)}}function zu(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(zt(e,t))return;s.uniform4fv(this.addr,t),Qt(e,t)}}function Qu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(zt(e,t))return;s.uniformMatrix2fv(this.addr,!1,t),Qt(e,t)}else{if(zt(e,n))return;Ds.set(n),s.uniformMatrix2fv(this.addr,!1,Ds),Qt(e,n)}}function Zu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(zt(e,t))return;s.uniformMatrix3fv(this.addr,!1,t),Qt(e,t)}else{if(zt(e,n))return;Ns.set(n),s.uniformMatrix3fv(this.addr,!1,Ns),Qt(e,n)}}function Yu(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(zt(e,t))return;s.uniformMatrix4fv(this.addr,!1,t),Qt(e,t)}else{if(zt(e,n))return;Fs.set(n),s.uniformMatrix4fv(this.addr,!1,Fs),Qt(e,n)}}function Xu(s,t){const e=this.cache;e[0]!==t&&(s.uniform1i(this.addr,t),e[0]=t)}function $u(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(zt(e,t))return;s.uniform2iv(this.addr,t),Qt(e,t)}}function th(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(zt(e,t))return;s.uniform3iv(this.addr,t),Qt(e,t)}}function eh(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(zt(e,t))return;s.uniform4iv(this.addr,t),Qt(e,t)}}function nh(s,t){const e=this.cache;e[0]!==t&&(s.uniform1ui(this.addr,t),e[0]=t)}function ih(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(zt(e,t))return;s.uniform2uiv(this.addr,t),Qt(e,t)}}function rh(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(zt(e,t))return;s.uniform3uiv(this.addr,t),Qt(e,t)}}function sh(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(zt(e,t))return;s.uniform4uiv(this.addr,t),Qt(e,t)}}function ah(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture2D(t||ya,i)}function oh(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||va,i)}function lh(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(t||Ma,i)}function ch(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Aa,i)}function uh(s){switch(s){case 5126:return qu;case 35664:return Gu;case 35665:return ju;case 35666:return zu;case 35674:return Qu;case 35675:return Zu;case 35676:return Yu;case 5124:case 35670:return Xu;case 35667:case 35671:return $u;case 35668:case 35672:return th;case 35669:case 35673:return eh;case 5125:return nh;case 36294:return ih;case 36295:return rh;case 36296:return sh;case 35678:case 36198:case 36298:case 36306:case 35682:return ah;case 35679:case 36299:case 36307:return oh;case 35680:case 36300:case 36308:case 36293:return lh;case 36289:case 36303:case 36311:case 36292:return ch}}function hh(s,t){s.uniform1fv(this.addr,t)}function dh(s,t){const e=qn(t,this.size,2);s.uniform2fv(this.addr,e)}function fh(s,t){const e=qn(t,this.size,3);s.uniform3fv(this.addr,e)}function ph(s,t){const e=qn(t,this.size,4);s.uniform4fv(this.addr,e)}function mh(s,t){const e=qn(t,this.size,4);s.uniformMatrix2fv(this.addr,!1,e)}function gh(s,t){const e=qn(t,this.size,9);s.uniformMatrix3fv(this.addr,!1,e)}function Sh(s,t){const e=qn(t,this.size,16);s.uniformMatrix4fv(this.addr,!1,e)}function xh(s,t){s.uniform1iv(this.addr,t)}function bh(s,t){s.uniform2iv(this.addr,t)}function yh(s,t){s.uniform3iv(this.addr,t)}function Ah(s,t){s.uniform4iv(this.addr,t)}function vh(s,t){s.uniform1uiv(this.addr,t)}function Mh(s,t){s.uniform2uiv(this.addr,t)}function Th(s,t){s.uniform3uiv(this.addr,t)}function Uh(s,t){s.uniform4uiv(this.addr,t)}function kh(s,t,e){const n=this.cache,i=t.length,r=Ni(e,i);zt(n,r)||(s.uniform1iv(this.addr,r),Qt(n,r));for(let o=0;o!==i;++o)e.setTexture2D(t[o]||ya,r[o])}function wh(s,t,e){const n=this.cache,i=t.length,r=Ni(e,i);zt(n,r)||(s.uniform1iv(this.addr,r),Qt(n,r));for(let o=0;o!==i;++o)e.setTexture3D(t[o]||va,r[o])}function Eh(s,t,e){const n=this.cache,i=t.length,r=Ni(e,i);zt(n,r)||(s.uniform1iv(this.addr,r),Qt(n,r));for(let o=0;o!==i;++o)e.setTextureCube(t[o]||Ma,r[o])}function Ch(s,t,e){const n=this.cache,i=t.length,r=Ni(e,i);zt(n,r)||(s.uniform1iv(this.addr,r),Qt(n,r));for(let o=0;o!==i;++o)e.setTexture2DArray(t[o]||Aa,r[o])}function Ih(s){switch(s){case 5126:return hh;case 35664:return dh;case 35665:return fh;case 35666:return ph;case 35674:return mh;case 35675:return gh;case 35676:return Sh;case 5124:case 35670:return xh;case 35667:case 35671:return bh;case 35668:case 35672:return yh;case 35669:case 35673:return Ah;case 5125:return vh;case 36294:return Mh;case 36295:return Th;case 36296:return Uh;case 35678:case 36198:case 36298:case 36306:case 35682:return kh;case 35679:case 36299:case 36307:return wh;case 35680:case 36300:case 36308:case 36293:return Eh;case 36289:case 36303:case 36311:case 36292:return Ch}}class Lh{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=uh(e.type)}}class Rh{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=Ih(e.type)}}class Ph{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let r=0,o=i.length;r!==o;++r){const a=i[r];a.setValue(t,e[a.id],n)}}}const Sr=/(\w+)(\])?(\[|\.)?/g;function Vs(s,t){s.seq.push(t),s.map[t.id]=t}function Fh(s,t,e){const n=s.name,i=n.length;for(Sr.lastIndex=0;;){const r=Sr.exec(n),o=Sr.lastIndex;let a=r[1];const c=r[2]==="]",l=r[3];if(c&&(a=a|0),l===void 0||l==="["&&o+2===i){Vs(e,l===void 0?new Lh(a,s,t):new Rh(a,s,t));break}else{let d=e.map[a];d===void 0&&(d=new Ph(a),Vs(e,d)),e=d}}}class Li{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const r=t.getActiveUniform(e,i),o=t.getUniformLocation(e,r.name);Fh(r,o,this)}}setValue(t,e,n,i){const r=this.map[e];r!==void 0&&r.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];i!==void 0&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let r=0,o=e.length;r!==o;++r){const a=e[r],c=n[a.id];c.needsUpdate!==!1&&a.setValue(t,c.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const o=t[i];o.id in e&&n.push(o)}return n}}function Ks(s,t,e){const n=s.createShader(t);return s.shaderSource(n,e),s.compileShader(n),n}let Nh=0;function Dh(s,t){const e=s.split(`
`),n=[],i=Math.max(t-6,0),r=Math.min(t+6,e.length);for(let o=i;o<r;o++){const a=o+1;n.push(`${a===t?">":" "} ${a}: ${e[o]}`)}return n.join(`
`)}function Vh(s){switch(s){case mn:return["Linear","( value )"];case Ot:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function Os(s,t,e){const n=s.getShaderParameter(t,35713),i=s.getShaderInfoLog(t).trim();if(n&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const o=parseInt(r[1]);return e.toUpperCase()+`

`+i+`

`+Dh(s.getShaderSource(t),o)}else return i}function Kh(s,t){const e=Vh(t);return"vec4 "+s+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function Oh(s,t){let e;switch(t){case to:e="Linear";break;case eo:e="Reinhard";break;case no:e="OptimizedCineon";break;case io:e="ACESFilmic";break;case ro:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+s+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Jh(s){return[s.extensionDerivatives||s.envMapCubeUVHeight||s.bumpMap||s.tangentSpaceNormalMap||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xn).join(`
`)}function Bh(s){const t=[];for(const e in s){const n=s[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function _h(s,t){const e={},n=s.getProgramParameter(t,35721);for(let i=0;i<n;i++){const r=s.getActiveAttrib(t,i),o=r.name;let a=1;r.type===35674&&(a=2),r.type===35675&&(a=3),r.type===35676&&(a=4),e[o]={type:r.type,location:s.getAttribLocation(t,o),locationSize:a}}return e}function Xn(s){return s!==""}function Js(s,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return s.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Bs(s,t){return s.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Hh=/^[ \t]*#include +<([\w\d./]+)>/gm;function Er(s){return s.replace(Hh,Wh)}function Wh(s,t){const e=vt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Er(e)}const qh=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function _s(s){return s.replace(qh,Gh)}function Gh(s,t,e,n){let i="";for(let r=parseInt(t);r<parseInt(e);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function Hs(s){let t="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?t+=`
#define HIGH_PRECISION`:s.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function jh(s){let t="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===ta?t="SHADOWMAP_TYPE_PCF":s.shadowMapType===Ra?t="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===Yn&&(t="SHADOWMAP_TYPE_VSM"),t}function zh(s){let t="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case Bn:case _n:t="ENVMAP_TYPE_CUBE";break;case Ri:t="ENVMAP_TYPE_CUBE_UV";break}return t}function Qh(s){let t="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case _n:t="ENVMAP_MODE_REFRACTION";break}return t}function Zh(s){let t="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case ia:t="ENVMAP_BLENDING_MULTIPLY";break;case Xa:t="ENVMAP_BLENDING_MIX";break;case $a:t="ENVMAP_BLENDING_ADD";break}return t}function Yh(s){const t=s.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function Xh(s,t,e,n){const i=s.getContext(),r=e.defines;let o=e.vertexShader,a=e.fragmentShader;const c=jh(e),l=zh(e),u=Qh(e),d=Zh(e),f=Yh(e),m=e.isWebGL2?"":Jh(e),b=Bh(r),p=i.createProgram();let h,S,k=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(h=[b].filter(Xn).join(`
`),h.length>0&&(h+=`
`),S=[m,b].filter(Xn).join(`
`),S.length>0&&(S+=`
`)):(h=[Hs(e),"#define SHADER_NAME "+e.shaderName,b,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors&&e.isWebGL2?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Xn).join(`
`),S=[m,Hs(e),"#define SHADER_NAME "+e.shaderName,b,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+l:"",e.envMap?"#define "+u:"",e.envMap?"#define "+d:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+c:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==He?"#define TONE_MAPPING":"",e.toneMapping!==He?vt.tonemapping_pars_fragment:"",e.toneMapping!==He?Oh("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",vt.encodings_pars_fragment,Kh("linearToOutputTexel",e.outputEncoding),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Xn).join(`
`)),o=Er(o),o=Js(o,e),o=Bs(o,e),a=Er(a),a=Js(a,e),a=Bs(a,e),o=_s(o),a=_s(a),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(k=`#version 300 es
`,h=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+h,S=["#define varying in",e.glslVersion===fs?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===fs?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+S);const T=k+h+o,M=k+S+a,y=Ks(i,35633,T),E=Ks(i,35632,M);if(i.attachShader(p,y),i.attachShader(p,E),e.index0AttributeName!==void 0?i.bindAttribLocation(p,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(p,0,"position"),i.linkProgram(p),s.debug.checkShaderErrors){const w=i.getProgramInfoLog(p).trim(),L=i.getShaderInfoLog(y).trim(),G=i.getShaderInfoLog(E).trim();let rt=!0,V=!0;if(i.getProgramParameter(p,35714)===!1){rt=!1;const F=Os(i,y,"vertex"),j=Os(i,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(p,35715)+`

Program Info Log: `+w+`
`+F+`
`+j)}else w!==""?console.warn("THREE.WebGLProgram: Program Info Log:",w):(L===""||G==="")&&(V=!1);V&&(this.diagnostics={runnable:rt,programLog:w,vertexShader:{log:L,prefix:h},fragmentShader:{log:G,prefix:S}})}i.deleteShader(y),i.deleteShader(E);let P;this.getUniforms=function(){return P===void 0&&(P=new Li(i,p)),P};let g;return this.getAttributes=function(){return g===void 0&&(g=_h(i,p)),g},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(p),this.program=void 0},this.name=e.shaderName,this.id=Nh++,this.cacheKey=t,this.usedTimes=1,this.program=p,this.vertexShader=y,this.fragmentShader=E,this}let $h=0;class td{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(n),o=this._getShaderCacheForMaterial(t);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new ed(t),e.set(t,n)),n}}class ed{constructor(t){this.id=$h++,this.code=t,this.usedTimes=0}}function nd(s,t,e,n,i,r,o){const a=new da,c=new td,l=[],u=i.isWebGL2,d=i.logarithmicDepthBuffer,f=i.vertexTextures;let m=i.precision;const b={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function p(g,w,L,G,rt){const V=G.fog,F=rt.geometry,j=g.isMeshStandardMaterial?G.environment:null,Z=(g.isMeshStandardMaterial?e:t).get(g.envMap||j),z=Z&&Z.mapping===Ri?Z.image.height:null,q=b[g.type];g.precision!==null&&(m=i.getMaxPrecision(g.precision),m!==g.precision&&console.warn("THREE.WebGLProgram.getParameters:",g.precision,"not supported, using",m,"instead."));const et=F.morphAttributes.position||F.morphAttributes.normal||F.morphAttributes.color,X=et!==void 0?et.length:0;let K=0;F.morphAttributes.position!==void 0&&(K=1),F.morphAttributes.normal!==void 0&&(K=2),F.morphAttributes.color!==void 0&&(K=3);let _,Y,tt,st;if(q){const Pt=Ie[q];_=Pt.vertexShader,Y=Pt.fragmentShader}else _=g.vertexShader,Y=g.fragmentShader,c.update(g),tt=c.getVertexShaderID(g),st=c.getFragmentShaderID(g);const H=s.getRenderTarget(),kt=g.alphaTest>0,dt=g.clearcoat>0,St=g.iridescence>0;return{isWebGL2:u,shaderID:q,shaderName:g.type,vertexShader:_,fragmentShader:Y,defines:g.defines,customVertexShaderID:tt,customFragmentShaderID:st,isRawShaderMaterial:g.isRawShaderMaterial===!0,glslVersion:g.glslVersion,precision:m,instancing:rt.isInstancedMesh===!0,instancingColor:rt.isInstancedMesh===!0&&rt.instanceColor!==null,supportsVertexTextures:f,outputEncoding:H===null?s.outputEncoding:H.isXRRenderTarget===!0?H.texture.encoding:mn,map:!!g.map,matcap:!!g.matcap,envMap:!!Z,envMapMode:Z&&Z.mapping,envMapCubeUVHeight:z,lightMap:!!g.lightMap,aoMap:!!g.aoMap,emissiveMap:!!g.emissiveMap,bumpMap:!!g.bumpMap,normalMap:!!g.normalMap,objectSpaceNormalMap:g.normalMapType===To,tangentSpaceNormalMap:g.normalMapType===aa,decodeVideoTexture:!!g.map&&g.map.isVideoTexture===!0&&g.map.encoding===Ot,clearcoat:dt,clearcoatMap:dt&&!!g.clearcoatMap,clearcoatRoughnessMap:dt&&!!g.clearcoatRoughnessMap,clearcoatNormalMap:dt&&!!g.clearcoatNormalMap,iridescence:St,iridescenceMap:St&&!!g.iridescenceMap,iridescenceThicknessMap:St&&!!g.iridescenceThicknessMap,displacementMap:!!g.displacementMap,roughnessMap:!!g.roughnessMap,metalnessMap:!!g.metalnessMap,specularMap:!!g.specularMap,specularIntensityMap:!!g.specularIntensityMap,specularColorMap:!!g.specularColorMap,opaque:g.transparent===!1&&g.blending===Kn,alphaMap:!!g.alphaMap,alphaTest:kt,gradientMap:!!g.gradientMap,sheen:g.sheen>0,sheenColorMap:!!g.sheenColorMap,sheenRoughnessMap:!!g.sheenRoughnessMap,transmission:g.transmission>0,transmissionMap:!!g.transmissionMap,thicknessMap:!!g.thicknessMap,combine:g.combine,vertexTangents:!!g.normalMap&&!!F.attributes.tangent,vertexColors:g.vertexColors,vertexAlphas:g.vertexColors===!0&&!!F.attributes.color&&F.attributes.color.itemSize===4,vertexUvs:!!g.map||!!g.bumpMap||!!g.normalMap||!!g.specularMap||!!g.alphaMap||!!g.emissiveMap||!!g.roughnessMap||!!g.metalnessMap||!!g.clearcoatMap||!!g.clearcoatRoughnessMap||!!g.clearcoatNormalMap||!!g.iridescenceMap||!!g.iridescenceThicknessMap||!!g.displacementMap||!!g.transmissionMap||!!g.thicknessMap||!!g.specularIntensityMap||!!g.specularColorMap||!!g.sheenColorMap||!!g.sheenRoughnessMap,uvsVertexOnly:!(g.map||g.bumpMap||g.normalMap||g.specularMap||g.alphaMap||g.emissiveMap||g.roughnessMap||g.metalnessMap||g.clearcoatNormalMap||g.iridescenceMap||g.iridescenceThicknessMap||g.transmission>0||g.transmissionMap||g.thicknessMap||g.specularIntensityMap||g.specularColorMap||g.sheen>0||g.sheenColorMap||g.sheenRoughnessMap)&&!!g.displacementMap,fog:!!V,useFog:g.fog===!0,fogExp2:V&&V.isFogExp2,flatShading:!!g.flatShading,sizeAttenuation:g.sizeAttenuation,logarithmicDepthBuffer:d,skinning:rt.isSkinnedMesh===!0,morphTargets:F.morphAttributes.position!==void 0,morphNormals:F.morphAttributes.normal!==void 0,morphColors:F.morphAttributes.color!==void 0,morphTargetsCount:X,morphTextureStride:K,numDirLights:w.directional.length,numPointLights:w.point.length,numSpotLights:w.spot.length,numSpotLightMaps:w.spotLightMap.length,numRectAreaLights:w.rectArea.length,numHemiLights:w.hemi.length,numDirLightShadows:w.directionalShadowMap.length,numPointLightShadows:w.pointShadowMap.length,numSpotLightShadows:w.spotShadowMap.length,numSpotLightShadowsWithMaps:w.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:g.dithering,shadowMapEnabled:s.shadowMap.enabled&&L.length>0,shadowMapType:s.shadowMap.type,toneMapping:g.toneMapped?s.toneMapping:He,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:g.premultipliedAlpha,doubleSided:g.side===_e,flipSided:g.side===Me,useDepthPacking:!!g.depthPacking,depthPacking:g.depthPacking||0,index0AttributeName:g.index0AttributeName,extensionDerivatives:g.extensions&&g.extensions.derivatives,extensionFragDepth:g.extensions&&g.extensions.fragDepth,extensionDrawBuffers:g.extensions&&g.extensions.drawBuffers,extensionShaderTextureLOD:g.extensions&&g.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:g.customProgramCacheKey()}}function h(g){const w=[];if(g.shaderID?w.push(g.shaderID):(w.push(g.customVertexShaderID),w.push(g.customFragmentShaderID)),g.defines!==void 0)for(const L in g.defines)w.push(L),w.push(g.defines[L]);return g.isRawShaderMaterial===!1&&(S(w,g),k(w,g),w.push(s.outputEncoding)),w.push(g.customProgramCacheKey),w.join()}function S(g,w){g.push(w.precision),g.push(w.outputEncoding),g.push(w.envMapMode),g.push(w.envMapCubeUVHeight),g.push(w.combine),g.push(w.vertexUvs),g.push(w.fogExp2),g.push(w.sizeAttenuation),g.push(w.morphTargetsCount),g.push(w.morphAttributeCount),g.push(w.numDirLights),g.push(w.numPointLights),g.push(w.numSpotLights),g.push(w.numSpotLightMaps),g.push(w.numHemiLights),g.push(w.numRectAreaLights),g.push(w.numDirLightShadows),g.push(w.numPointLightShadows),g.push(w.numSpotLightShadows),g.push(w.numSpotLightShadowsWithMaps),g.push(w.shadowMapType),g.push(w.toneMapping),g.push(w.numClippingPlanes),g.push(w.numClipIntersection),g.push(w.depthPacking)}function k(g,w){a.disableAll(),w.isWebGL2&&a.enable(0),w.supportsVertexTextures&&a.enable(1),w.instancing&&a.enable(2),w.instancingColor&&a.enable(3),w.map&&a.enable(4),w.matcap&&a.enable(5),w.envMap&&a.enable(6),w.lightMap&&a.enable(7),w.aoMap&&a.enable(8),w.emissiveMap&&a.enable(9),w.bumpMap&&a.enable(10),w.normalMap&&a.enable(11),w.objectSpaceNormalMap&&a.enable(12),w.tangentSpaceNormalMap&&a.enable(13),w.clearcoat&&a.enable(14),w.clearcoatMap&&a.enable(15),w.clearcoatRoughnessMap&&a.enable(16),w.clearcoatNormalMap&&a.enable(17),w.iridescence&&a.enable(18),w.iridescenceMap&&a.enable(19),w.iridescenceThicknessMap&&a.enable(20),w.displacementMap&&a.enable(21),w.specularMap&&a.enable(22),w.roughnessMap&&a.enable(23),w.metalnessMap&&a.enable(24),w.gradientMap&&a.enable(25),w.alphaMap&&a.enable(26),w.alphaTest&&a.enable(27),w.vertexColors&&a.enable(28),w.vertexAlphas&&a.enable(29),w.vertexUvs&&a.enable(30),w.vertexTangents&&a.enable(31),w.uvsVertexOnly&&a.enable(32),g.push(a.mask),a.disableAll(),w.fog&&a.enable(0),w.useFog&&a.enable(1),w.flatShading&&a.enable(2),w.logarithmicDepthBuffer&&a.enable(3),w.skinning&&a.enable(4),w.morphTargets&&a.enable(5),w.morphNormals&&a.enable(6),w.morphColors&&a.enable(7),w.premultipliedAlpha&&a.enable(8),w.shadowMapEnabled&&a.enable(9),w.physicallyCorrectLights&&a.enable(10),w.doubleSided&&a.enable(11),w.flipSided&&a.enable(12),w.useDepthPacking&&a.enable(13),w.dithering&&a.enable(14),w.specularIntensityMap&&a.enable(15),w.specularColorMap&&a.enable(16),w.transmission&&a.enable(17),w.transmissionMap&&a.enable(18),w.thicknessMap&&a.enable(19),w.sheen&&a.enable(20),w.sheenColorMap&&a.enable(21),w.sheenRoughnessMap&&a.enable(22),w.decodeVideoTexture&&a.enable(23),w.opaque&&a.enable(24),g.push(a.mask)}function T(g){const w=b[g.type];let L;if(w){const G=Ie[w];L=Bo.clone(G.uniforms)}else L=g.uniforms;return L}function M(g,w){let L;for(let G=0,rt=l.length;G<rt;G++){const V=l[G];if(V.cacheKey===w){L=V,++L.usedTimes;break}}return L===void 0&&(L=new Xh(s,w,g,r),l.push(L)),L}function y(g){if(--g.usedTimes===0){const w=l.indexOf(g);l[w]=l[l.length-1],l.pop(),g.destroy()}}function E(g){c.remove(g)}function P(){c.dispose()}return{getParameters:p,getProgramCacheKey:h,getUniforms:T,acquireProgram:M,releaseProgram:y,releaseShaderCache:E,programs:l,dispose:P}}function id(){let s=new WeakMap;function t(r){let o=s.get(r);return o===void 0&&(o={},s.set(r,o)),o}function e(r){s.delete(r)}function n(r,o,a){s.get(r)[o]=a}function i(){s=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function rd(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.material.id!==t.material.id?s.material.id-t.material.id:s.z!==t.z?s.z-t.z:s.id-t.id}function Ws(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.z!==t.z?t.z-s.z:s.id-t.id}function qs(){const s=[];let t=0;const e=[],n=[],i=[];function r(){t=0,e.length=0,n.length=0,i.length=0}function o(d,f,m,b,p,h){let S=s[t];return S===void 0?(S={id:d.id,object:d,geometry:f,material:m,groupOrder:b,renderOrder:d.renderOrder,z:p,group:h},s[t]=S):(S.id=d.id,S.object=d,S.geometry=f,S.material=m,S.groupOrder=b,S.renderOrder=d.renderOrder,S.z=p,S.group=h),t++,S}function a(d,f,m,b,p,h){const S=o(d,f,m,b,p,h);m.transmission>0?n.push(S):m.transparent===!0?i.push(S):e.push(S)}function c(d,f,m,b,p,h){const S=o(d,f,m,b,p,h);m.transmission>0?n.unshift(S):m.transparent===!0?i.unshift(S):e.unshift(S)}function l(d,f){e.length>1&&e.sort(d||rd),n.length>1&&n.sort(f||Ws),i.length>1&&i.sort(f||Ws)}function u(){for(let d=t,f=s.length;d<f;d++){const m=s[d];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.group=null}}return{opaque:e,transmissive:n,transparent:i,init:r,push:a,unshift:c,finish:u,sort:l}}function sd(){let s=new WeakMap;function t(n,i){const r=s.get(n);let o;return r===void 0?(o=new qs,s.set(n,[o])):i>=r.length?(o=new qs,r.push(o)):o=r[i],o}function e(){s=new WeakMap}return{get:t,dispose:e}}function ad(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new N,color:new Vt};break;case"SpotLight":e={position:new N,direction:new N,color:new Vt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new N,color:new Vt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new N,skyColor:new Vt,groundColor:new Vt};break;case"RectAreaLight":e={color:new Vt,position:new N,halfWidth:new N,halfHeight:new N};break}return s[t.id]=e,e}}}function od(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Mt,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[t.id]=e,e}}}let ld=0;function cd(s,t){return(t.castShadow?2:0)-(s.castShadow?2:0)+(t.map?1:0)-(s.map?1:0)}function ud(s,t){const e=new ad,n=od(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let u=0;u<9;u++)i.probe.push(new N);const r=new N,o=new jt,a=new jt;function c(u,d){let f=0,m=0,b=0;for(let G=0;G<9;G++)i.probe[G].set(0,0,0);let p=0,h=0,S=0,k=0,T=0,M=0,y=0,E=0,P=0,g=0;u.sort(cd);const w=d!==!0?Math.PI:1;for(let G=0,rt=u.length;G<rt;G++){const V=u[G],F=V.color,j=V.intensity,Z=V.distance,z=V.shadow&&V.shadow.map?V.shadow.map.texture:null;if(V.isAmbientLight)f+=F.r*j*w,m+=F.g*j*w,b+=F.b*j*w;else if(V.isLightProbe)for(let q=0;q<9;q++)i.probe[q].addScaledVector(V.sh.coefficients[q],j);else if(V.isDirectionalLight){const q=e.get(V);if(q.color.copy(V.color).multiplyScalar(V.intensity*w),V.castShadow){const et=V.shadow,X=n.get(V);X.shadowBias=et.bias,X.shadowNormalBias=et.normalBias,X.shadowRadius=et.radius,X.shadowMapSize=et.mapSize,i.directionalShadow[p]=X,i.directionalShadowMap[p]=z,i.directionalShadowMatrix[p]=V.shadow.matrix,M++}i.directional[p]=q,p++}else if(V.isSpotLight){const q=e.get(V);q.position.setFromMatrixPosition(V.matrixWorld),q.color.copy(F).multiplyScalar(j*w),q.distance=Z,q.coneCos=Math.cos(V.angle),q.penumbraCos=Math.cos(V.angle*(1-V.penumbra)),q.decay=V.decay,i.spot[S]=q;const et=V.shadow;if(V.map&&(i.spotLightMap[P]=V.map,P++,et.updateMatrices(V),V.castShadow&&g++),i.spotLightMatrix[S]=et.matrix,V.castShadow){const X=n.get(V);X.shadowBias=et.bias,X.shadowNormalBias=et.normalBias,X.shadowRadius=et.radius,X.shadowMapSize=et.mapSize,i.spotShadow[S]=X,i.spotShadowMap[S]=z,E++}S++}else if(V.isRectAreaLight){const q=e.get(V);q.color.copy(F).multiplyScalar(j),q.halfWidth.set(V.width*.5,0,0),q.halfHeight.set(0,V.height*.5,0),i.rectArea[k]=q,k++}else if(V.isPointLight){const q=e.get(V);if(q.color.copy(V.color).multiplyScalar(V.intensity*w),q.distance=V.distance,q.decay=V.decay,V.castShadow){const et=V.shadow,X=n.get(V);X.shadowBias=et.bias,X.shadowNormalBias=et.normalBias,X.shadowRadius=et.radius,X.shadowMapSize=et.mapSize,X.shadowCameraNear=et.camera.near,X.shadowCameraFar=et.camera.far,i.pointShadow[h]=X,i.pointShadowMap[h]=z,i.pointShadowMatrix[h]=V.shadow.matrix,y++}i.point[h]=q,h++}else if(V.isHemisphereLight){const q=e.get(V);q.skyColor.copy(V.color).multiplyScalar(j*w),q.groundColor.copy(V.groundColor).multiplyScalar(j*w),i.hemi[T]=q,T++}}k>0&&(t.isWebGL2||s.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=it.LTC_FLOAT_1,i.rectAreaLTC2=it.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=it.LTC_HALF_1,i.rectAreaLTC2=it.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=f,i.ambient[1]=m,i.ambient[2]=b;const L=i.hash;(L.directionalLength!==p||L.pointLength!==h||L.spotLength!==S||L.rectAreaLength!==k||L.hemiLength!==T||L.numDirectionalShadows!==M||L.numPointShadows!==y||L.numSpotShadows!==E||L.numSpotMaps!==P)&&(i.directional.length=p,i.spot.length=S,i.rectArea.length=k,i.point.length=h,i.hemi.length=T,i.directionalShadow.length=M,i.directionalShadowMap.length=M,i.pointShadow.length=y,i.pointShadowMap.length=y,i.spotShadow.length=E,i.spotShadowMap.length=E,i.directionalShadowMatrix.length=M,i.pointShadowMatrix.length=y,i.spotLightMatrix.length=E+P-g,i.spotLightMap.length=P,i.numSpotLightShadowsWithMaps=g,L.directionalLength=p,L.pointLength=h,L.spotLength=S,L.rectAreaLength=k,L.hemiLength=T,L.numDirectionalShadows=M,L.numPointShadows=y,L.numSpotShadows=E,L.numSpotMaps=P,i.version=ld++)}function l(u,d){let f=0,m=0,b=0,p=0,h=0;const S=d.matrixWorldInverse;for(let k=0,T=u.length;k<T;k++){const M=u[k];if(M.isDirectionalLight){const y=i.directional[f];y.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),y.direction.sub(r),y.direction.transformDirection(S),f++}else if(M.isSpotLight){const y=i.spot[b];y.position.setFromMatrixPosition(M.matrixWorld),y.position.applyMatrix4(S),y.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),y.direction.sub(r),y.direction.transformDirection(S),b++}else if(M.isRectAreaLight){const y=i.rectArea[p];y.position.setFromMatrixPosition(M.matrixWorld),y.position.applyMatrix4(S),a.identity(),o.copy(M.matrixWorld),o.premultiply(S),a.extractRotation(o),y.halfWidth.set(M.width*.5,0,0),y.halfHeight.set(0,M.height*.5,0),y.halfWidth.applyMatrix4(a),y.halfHeight.applyMatrix4(a),p++}else if(M.isPointLight){const y=i.point[m];y.position.setFromMatrixPosition(M.matrixWorld),y.position.applyMatrix4(S),m++}else if(M.isHemisphereLight){const y=i.hemi[h];y.direction.setFromMatrixPosition(M.matrixWorld),y.direction.transformDirection(S),h++}}}return{setup:c,setupView:l,state:i}}function Gs(s,t){const e=new ud(s,t),n=[],i=[];function r(){n.length=0,i.length=0}function o(d){n.push(d)}function a(d){i.push(d)}function c(d){e.setup(n,d)}function l(d){e.setupView(n,d)}return{init:r,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:c,setupLightsView:l,pushLight:o,pushShadow:a}}function hd(s,t){let e=new WeakMap;function n(r,o=0){const a=e.get(r);let c;return a===void 0?(c=new Gs(s,t),e.set(r,[c])):o>=a.length?(c=new Gs(s,t),a.push(c)):c=a[o],c}function i(){e=new WeakMap}return{get:n,dispose:i}}class dd extends ai{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=vo,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class fd extends ai{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new N,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const pd=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,md=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function gd(s,t,e){let n=new Lr;const i=new Mt,r=new Mt,o=new te,a=new dd({depthPacking:Mo}),c=new fd,l={},u=e.maxTextureSize,d={0:Me,1:Jn,2:_e},f=new xn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Mt},radius:{value:4}},vertexShader:pd,fragmentShader:md}),m=f.clone();m.defines.HORIZONTAL_PASS=1;const b=new Xe;b.setAttribute("position",new Re(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new Le(b,f),h=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ta,this.render=function(M,y,E){if(h.enabled===!1||h.autoUpdate===!1&&h.needsUpdate===!1||M.length===0)return;const P=s.getRenderTarget(),g=s.getActiveCubeFace(),w=s.getActiveMipmapLevel(),L=s.state;L.setBlending(Ye),L.buffers.color.setClear(1,1,1,1),L.buffers.depth.setTest(!0),L.setScissorTest(!1);for(let G=0,rt=M.length;G<rt;G++){const V=M[G],F=V.shadow;if(F===void 0){console.warn("THREE.WebGLShadowMap:",V,"has no shadow.");continue}if(F.autoUpdate===!1&&F.needsUpdate===!1)continue;i.copy(F.mapSize);const j=F.getFrameExtents();if(i.multiply(j),r.copy(F.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/j.x),i.x=r.x*j.x,F.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/j.y),i.y=r.y*j.y,F.mapSize.y=r.y)),F.map===null){const z=this.type!==Yn?{minFilter:ce,magFilter:ce}:{};F.map=new gn(i.x,i.y,z),F.map.texture.name=V.name+".shadowMap",F.camera.updateProjectionMatrix()}s.setRenderTarget(F.map),s.clear();const Z=F.getViewportCount();for(let z=0;z<Z;z++){const q=F.getViewport(z);o.set(r.x*q.x,r.y*q.y,r.x*q.z,r.y*q.w),L.viewport(o),F.updateMatrices(V,z),n=F.getFrustum(),T(y,E,F.camera,V,this.type)}F.isPointLightShadow!==!0&&this.type===Yn&&S(F,E),F.needsUpdate=!1}h.needsUpdate=!1,s.setRenderTarget(P,g,w)};function S(M,y){const E=t.update(p);f.defines.VSM_SAMPLES!==M.blurSamples&&(f.defines.VSM_SAMPLES=M.blurSamples,m.defines.VSM_SAMPLES=M.blurSamples,f.needsUpdate=!0,m.needsUpdate=!0),M.mapPass===null&&(M.mapPass=new gn(i.x,i.y)),f.uniforms.shadow_pass.value=M.map.texture,f.uniforms.resolution.value=M.mapSize,f.uniforms.radius.value=M.radius,s.setRenderTarget(M.mapPass),s.clear(),s.renderBufferDirect(y,null,E,f,p,null),m.uniforms.shadow_pass.value=M.mapPass.texture,m.uniforms.resolution.value=M.mapSize,m.uniforms.radius.value=M.radius,s.setRenderTarget(M.map),s.clear(),s.renderBufferDirect(y,null,E,m,p,null)}function k(M,y,E,P,g,w){let L=null;const G=E.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(G!==void 0?L=G:L=E.isPointLight===!0?c:a,s.localClippingEnabled&&y.clipShadows===!0&&Array.isArray(y.clippingPlanes)&&y.clippingPlanes.length!==0||y.displacementMap&&y.displacementScale!==0||y.alphaMap&&y.alphaTest>0||y.map&&y.alphaTest>0){const rt=L.uuid,V=y.uuid;let F=l[rt];F===void 0&&(F={},l[rt]=F);let j=F[V];j===void 0&&(j=L.clone(),F[V]=j),L=j}return L.visible=y.visible,L.wireframe=y.wireframe,w===Yn?L.side=y.shadowSide!==null?y.shadowSide:y.side:L.side=y.shadowSide!==null?y.shadowSide:d[y.side],L.alphaMap=y.alphaMap,L.alphaTest=y.alphaTest,L.map=y.map,L.clipShadows=y.clipShadows,L.clippingPlanes=y.clippingPlanes,L.clipIntersection=y.clipIntersection,L.displacementMap=y.displacementMap,L.displacementScale=y.displacementScale,L.displacementBias=y.displacementBias,L.wireframeLinewidth=y.wireframeLinewidth,L.linewidth=y.linewidth,E.isPointLight===!0&&L.isMeshDistanceMaterial===!0&&(L.referencePosition.setFromMatrixPosition(E.matrixWorld),L.nearDistance=P,L.farDistance=g),L}function T(M,y,E,P,g){if(M.visible===!1)return;if(M.layers.test(y.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&g===Yn)&&(!M.frustumCulled||n.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse,M.matrixWorld);const G=t.update(M),rt=M.material;if(Array.isArray(rt)){const V=G.groups;for(let F=0,j=V.length;F<j;F++){const Z=V[F],z=rt[Z.materialIndex];if(z&&z.visible){const q=k(M,z,P,E.near,E.far,g);s.renderBufferDirect(E,null,G,q,M,Z)}}}else if(rt.visible){const V=k(M,rt,P,E.near,E.far,g);s.renderBufferDirect(E,null,G,V,M,null)}}const L=M.children;for(let G=0,rt=L.length;G<rt;G++)T(L[G],y,E,P,g)}}function Sd(s,t,e){const n=e.isWebGL2;function i(){let C=!1;const B=new te;let Q=null;const ct=new te(0,0,0,0);return{setMask:function(mt){Q!==mt&&!C&&(s.colorMask(mt,mt,mt,mt),Q=mt)},setLocked:function(mt){C=mt},setClear:function(mt,Ft,Yt,ee,$e){$e===!0&&(mt*=ee,Ft*=ee,Yt*=ee),B.set(mt,Ft,Yt,ee),ct.equals(B)===!1&&(s.clearColor(mt,Ft,Yt,ee),ct.copy(B))},reset:function(){C=!1,Q=null,ct.set(-1,0,0,0)}}}function r(){let C=!1,B=null,Q=null,ct=null;return{setTest:function(mt){mt?kt(2929):dt(2929)},setMask:function(mt){B!==mt&&!C&&(s.depthMask(mt),B=mt)},setFunc:function(mt){if(Q!==mt){switch(mt){case qa:s.depthFunc(512);break;case Ga:s.depthFunc(519);break;case ja:s.depthFunc(513);break;case Ar:s.depthFunc(515);break;case za:s.depthFunc(514);break;case Qa:s.depthFunc(518);break;case Za:s.depthFunc(516);break;case Ya:s.depthFunc(517);break;default:s.depthFunc(515)}Q=mt}},setLocked:function(mt){C=mt},setClear:function(mt){ct!==mt&&(s.clearDepth(mt),ct=mt)},reset:function(){C=!1,B=null,Q=null,ct=null}}}function o(){let C=!1,B=null,Q=null,ct=null,mt=null,Ft=null,Yt=null,ee=null,$e=null;return{setTest:function(Kt){C||(Kt?kt(2960):dt(2960))},setMask:function(Kt){B!==Kt&&!C&&(s.stencilMask(Kt),B=Kt)},setFunc:function(Kt,Fe,ye){(Q!==Kt||ct!==Fe||mt!==ye)&&(s.stencilFunc(Kt,Fe,ye),Q=Kt,ct=Fe,mt=ye)},setOp:function(Kt,Fe,ye){(Ft!==Kt||Yt!==Fe||ee!==ye)&&(s.stencilOp(Kt,Fe,ye),Ft=Kt,Yt=Fe,ee=ye)},setLocked:function(Kt){C=Kt},setClear:function(Kt){$e!==Kt&&(s.clearStencil(Kt),$e=Kt)},reset:function(){C=!1,B=null,Q=null,ct=null,mt=null,Ft=null,Yt=null,ee=null,$e=null}}}const a=new i,c=new r,l=new o,u=new WeakMap,d=new WeakMap;let f={},m={},b=new WeakMap,p=[],h=null,S=!1,k=null,T=null,M=null,y=null,E=null,P=null,g=null,w=!1,L=null,G=null,rt=null,V=null,F=null;const j=s.getParameter(35661);let Z=!1,z=0;const q=s.getParameter(7938);q.indexOf("WebGL")!==-1?(z=parseFloat(/^WebGL (\d)/.exec(q)[1]),Z=z>=1):q.indexOf("OpenGL ES")!==-1&&(z=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),Z=z>=2);let et=null,X={};const K=s.getParameter(3088),_=s.getParameter(2978),Y=new te().fromArray(K),tt=new te().fromArray(_);function st(C,B,Q){const ct=new Uint8Array(4),mt=s.createTexture();s.bindTexture(C,mt),s.texParameteri(C,10241,9728),s.texParameteri(C,10240,9728);for(let Ft=0;Ft<Q;Ft++)s.texImage2D(B+Ft,0,6408,1,1,0,6408,5121,ct);return mt}const H={};H[3553]=st(3553,3553,1),H[34067]=st(34067,34069,6),a.setClear(0,0,0,1),c.setClear(1),l.setClear(0),kt(2929),c.setFunc(Ar),qt(!1),re(Vr),kt(2884),Zt(Ye);function kt(C){f[C]!==!0&&(s.enable(C),f[C]=!0)}function dt(C){f[C]!==!1&&(s.disable(C),f[C]=!1)}function St(C,B){return m[C]!==B?(s.bindFramebuffer(C,B),m[C]=B,n&&(C===36009&&(m[36160]=B),C===36160&&(m[36009]=B)),!0):!1}function ht(C,B){let Q=p,ct=!1;if(C)if(Q=b.get(B),Q===void 0&&(Q=[],b.set(B,Q)),C.isWebGLMultipleRenderTargets){const mt=C.texture;if(Q.length!==mt.length||Q[0]!==36064){for(let Ft=0,Yt=mt.length;Ft<Yt;Ft++)Q[Ft]=36064+Ft;Q.length=mt.length,ct=!0}}else Q[0]!==36064&&(Q[0]=36064,ct=!0);else Q[0]!==1029&&(Q[0]=1029,ct=!0);ct&&(e.isWebGL2?s.drawBuffers(Q):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(Q))}function Pt(C){return h!==C?(s.useProgram(C),h=C,!0):!1}const At={[Dn]:32774,[Fa]:32778,[Na]:32779};if(n)At[Br]=32775,At[_r]=32776;else{const C=t.get("EXT_blend_minmax");C!==null&&(At[Br]=C.MIN_EXT,At[_r]=C.MAX_EXT)}const xt={[Da]:0,[Va]:1,[Ka]:768,[ea]:770,[Wa]:776,[_a]:774,[Ja]:772,[Oa]:769,[na]:771,[Ha]:775,[Ba]:773};function Zt(C,B,Q,ct,mt,Ft,Yt,ee){if(C===Ye){S===!0&&(dt(3042),S=!1);return}if(S===!1&&(kt(3042),S=!0),C!==Pa){if(C!==k||ee!==w){if((T!==Dn||E!==Dn)&&(s.blendEquation(32774),T=Dn,E=Dn),ee)switch(C){case Kn:s.blendFuncSeparate(1,771,1,771);break;case Kr:s.blendFunc(1,1);break;case Or:s.blendFuncSeparate(0,769,0,1);break;case Jr:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}else switch(C){case Kn:s.blendFuncSeparate(770,771,1,771);break;case Kr:s.blendFunc(770,1);break;case Or:s.blendFuncSeparate(0,769,0,1);break;case Jr:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}M=null,y=null,P=null,g=null,k=C,w=ee}return}mt=mt||B,Ft=Ft||Q,Yt=Yt||ct,(B!==T||mt!==E)&&(s.blendEquationSeparate(At[B],At[mt]),T=B,E=mt),(Q!==M||ct!==y||Ft!==P||Yt!==g)&&(s.blendFuncSeparate(xt[Q],xt[ct],xt[Ft],xt[Yt]),M=Q,y=ct,P=Ft,g=Yt),k=C,w=!1}function Wt(C,B){C.side===_e?dt(2884):kt(2884);let Q=C.side===Me;B&&(Q=!Q),qt(Q),C.blending===Kn&&C.transparent===!1?Zt(Ye):Zt(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),c.setFunc(C.depthFunc),c.setTest(C.depthTest),c.setMask(C.depthWrite),a.setMask(C.colorWrite);const ct=C.stencilWrite;l.setTest(ct),ct&&(l.setMask(C.stencilWriteMask),l.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),l.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),Nt(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?kt(32926):dt(32926)}function qt(C){L!==C&&(C?s.frontFace(2304):s.frontFace(2305),L=C)}function re(C){C!==Ia?(kt(2884),C!==G&&(C===Vr?s.cullFace(1029):C===La?s.cullFace(1028):s.cullFace(1032))):dt(2884),G=C}function Jt(C){C!==rt&&(Z&&s.lineWidth(C),rt=C)}function Nt(C,B,Q){C?(kt(32823),(V!==B||F!==Q)&&(s.polygonOffset(B,Q),V=B,F=Q)):dt(32823)}function be(C){C?kt(3089):dt(3089)}function le(C){C===void 0&&(C=33984+j-1),et!==C&&(s.activeTexture(C),et=C)}function v(C,B,Q){Q===void 0&&(et===null?Q=33984+j-1:Q=et);let ct=X[Q];ct===void 0&&(ct={type:void 0,texture:void 0},X[Q]=ct),(ct.type!==C||ct.texture!==B)&&(et!==Q&&(s.activeTexture(Q),et=Q),s.bindTexture(C,B||H[C]),ct.type=C,ct.texture=B)}function x(){const C=X[et];C!==void 0&&C.type!==void 0&&(s.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)}function O(){try{s.compressedTexImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function $(){try{s.compressedTexImage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function nt(){try{s.texSubImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function at(){try{s.texSubImage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function bt(){try{s.compressedTexSubImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function U(){try{s.compressedTexSubImage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function I(){try{s.texStorage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function lt(){try{s.texStorage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function ut(){try{s.texImage2D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function ot(){try{s.texImage3D.apply(s,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function pt(C){Y.equals(C)===!1&&(s.scissor(C.x,C.y,C.z,C.w),Y.copy(C))}function ft(C){tt.equals(C)===!1&&(s.viewport(C.x,C.y,C.z,C.w),tt.copy(C))}function wt(C,B){let Q=d.get(B);Q===void 0&&(Q=new WeakMap,d.set(B,Q));let ct=Q.get(C);ct===void 0&&(ct=s.getUniformBlockIndex(B,C.name),Q.set(C,ct))}function Et(C,B){const ct=d.get(B).get(C);u.get(C)!==ct&&(s.uniformBlockBinding(B,ct,C.__bindingPointIndex),u.set(C,ct))}function Dt(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),n===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),f={},et=null,X={},m={},b=new WeakMap,p=[],h=null,S=!1,k=null,T=null,M=null,y=null,E=null,P=null,g=null,w=!1,L=null,G=null,rt=null,V=null,F=null,Y.set(0,0,s.canvas.width,s.canvas.height),tt.set(0,0,s.canvas.width,s.canvas.height),a.reset(),c.reset(),l.reset()}return{buffers:{color:a,depth:c,stencil:l},enable:kt,disable:dt,bindFramebuffer:St,drawBuffers:ht,useProgram:Pt,setBlending:Zt,setMaterial:Wt,setFlipSided:qt,setCullFace:re,setLineWidth:Jt,setPolygonOffset:Nt,setScissorTest:be,activeTexture:le,bindTexture:v,unbindTexture:x,compressedTexImage2D:O,compressedTexImage3D:$,texImage2D:ut,texImage3D:ot,updateUBOMapping:wt,uniformBlockBinding:Et,texStorage2D:I,texStorage3D:lt,texSubImage2D:nt,texSubImage3D:at,compressedTexSubImage2D:bt,compressedTexSubImage3D:U,scissor:pt,viewport:ft,reset:Dt}}function xd(s,t,e,n,i,r,o){const a=i.isWebGL2,c=i.maxTextures,l=i.maxCubemapSize,u=i.maxTextureSize,d=i.maxSamples,f=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,m=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),b=new WeakMap;let p;const h=new WeakMap;let S=!1;try{S=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function k(v,x){return S?new OffscreenCanvas(v,x):ni("canvas")}function T(v,x,O,$){let nt=1;if((v.width>$||v.height>$)&&(nt=$/Math.max(v.width,v.height)),nt<1||x===!0)if(typeof HTMLImageElement<"u"&&v instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&v instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&v instanceof ImageBitmap){const at=x?wr:Math.floor,bt=at(nt*v.width),U=at(nt*v.height);p===void 0&&(p=k(bt,U));const I=O?k(bt,U):p;return I.width=bt,I.height=U,I.getContext("2d").drawImage(v,0,0,bt,U),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+v.width+"x"+v.height+") to ("+bt+"x"+U+")."),I}else return"data"in v&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+v.width+"x"+v.height+")."),v;return v}function M(v){return ps(v.width)&&ps(v.height)}function y(v){return a?!1:v.wrapS!==we||v.wrapT!==we||v.minFilter!==ce&&v.minFilter!==ve}function E(v,x){return v.generateMipmaps&&x&&v.minFilter!==ce&&v.minFilter!==ve}function P(v){s.generateMipmap(v)}function g(v,x,O,$,nt=!1){if(a===!1)return x;if(v!==null){if(s[v]!==void 0)return s[v];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+v+"'")}let at=x;return x===6403&&(O===5126&&(at=33326),O===5131&&(at=33325),O===5121&&(at=33321)),x===33319&&(O===5126&&(at=33328),O===5131&&(at=33327),O===5121&&(at=33323)),x===6408&&(O===5126&&(at=34836),O===5131&&(at=34842),O===5121&&(at=$===Ot&&nt===!1?35907:32856),O===32819&&(at=32854),O===32820&&(at=32855)),(at===33325||at===33326||at===33327||at===33328||at===34842||at===34836)&&t.get("EXT_color_buffer_float"),at}function w(v,x,O){return E(v,O)===!0||v.isFramebufferTexture&&v.minFilter!==ce&&v.minFilter!==ve?Math.log2(Math.max(x.width,x.height))+1:v.mipmaps!==void 0&&v.mipmaps.length>0?v.mipmaps.length:v.isCompressedTexture&&Array.isArray(v.image)?x.mipmaps.length:1}function L(v){return v===ce||v===Hr||v===Wr?9728:9729}function G(v){const x=v.target;x.removeEventListener("dispose",G),V(x),x.isVideoTexture&&b.delete(x)}function rt(v){const x=v.target;x.removeEventListener("dispose",rt),j(x)}function V(v){const x=n.get(v);if(x.__webglInit===void 0)return;const O=v.source,$=h.get(O);if($){const nt=$[x.__cacheKey];nt.usedTimes--,nt.usedTimes===0&&F(v),Object.keys($).length===0&&h.delete(O)}n.remove(v)}function F(v){const x=n.get(v);s.deleteTexture(x.__webglTexture);const O=v.source,$=h.get(O);delete $[x.__cacheKey],o.memory.textures--}function j(v){const x=v.texture,O=n.get(v),$=n.get(x);if($.__webglTexture!==void 0&&(s.deleteTexture($.__webglTexture),o.memory.textures--),v.depthTexture&&v.depthTexture.dispose(),v.isWebGLCubeRenderTarget)for(let nt=0;nt<6;nt++)s.deleteFramebuffer(O.__webglFramebuffer[nt]),O.__webglDepthbuffer&&s.deleteRenderbuffer(O.__webglDepthbuffer[nt]);else{if(s.deleteFramebuffer(O.__webglFramebuffer),O.__webglDepthbuffer&&s.deleteRenderbuffer(O.__webglDepthbuffer),O.__webglMultisampledFramebuffer&&s.deleteFramebuffer(O.__webglMultisampledFramebuffer),O.__webglColorRenderbuffer)for(let nt=0;nt<O.__webglColorRenderbuffer.length;nt++)O.__webglColorRenderbuffer[nt]&&s.deleteRenderbuffer(O.__webglColorRenderbuffer[nt]);O.__webglDepthRenderbuffer&&s.deleteRenderbuffer(O.__webglDepthRenderbuffer)}if(v.isWebGLMultipleRenderTargets)for(let nt=0,at=x.length;nt<at;nt++){const bt=n.get(x[nt]);bt.__webglTexture&&(s.deleteTexture(bt.__webglTexture),o.memory.textures--),n.remove(x[nt])}n.remove(x),n.remove(v)}let Z=0;function z(){Z=0}function q(){const v=Z;return v>=c&&console.warn("THREE.WebGLTextures: Trying to use "+v+" texture units while this GPU supports only "+c),Z+=1,v}function et(v){const x=[];return x.push(v.wrapS),x.push(v.wrapT),x.push(v.wrapR||0),x.push(v.magFilter),x.push(v.minFilter),x.push(v.anisotropy),x.push(v.internalFormat),x.push(v.format),x.push(v.type),x.push(v.generateMipmaps),x.push(v.premultiplyAlpha),x.push(v.flipY),x.push(v.unpackAlignment),x.push(v.encoding),x.join()}function X(v,x){const O=n.get(v);if(v.isVideoTexture&&be(v),v.isRenderTargetTexture===!1&&v.version>0&&O.__version!==v.version){const $=v.image;if($===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if($.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{dt(O,v,x);return}}e.bindTexture(3553,O.__webglTexture,33984+x)}function K(v,x){const O=n.get(v);if(v.version>0&&O.__version!==v.version){dt(O,v,x);return}e.bindTexture(35866,O.__webglTexture,33984+x)}function _(v,x){const O=n.get(v);if(v.version>0&&O.__version!==v.version){dt(O,v,x);return}e.bindTexture(32879,O.__webglTexture,33984+x)}function Y(v,x){const O=n.get(v);if(v.version>0&&O.__version!==v.version){St(O,v,x);return}e.bindTexture(34067,O.__webglTexture,33984+x)}const tt={[$n]:10497,[we]:33071,[Tr]:33648},st={[ce]:9728,[Hr]:9984,[Wr]:9986,[ve]:9729,[so]:9985,[Pi]:9987};function H(v,x,O){if(O?(s.texParameteri(v,10242,tt[x.wrapS]),s.texParameteri(v,10243,tt[x.wrapT]),(v===32879||v===35866)&&s.texParameteri(v,32882,tt[x.wrapR]),s.texParameteri(v,10240,st[x.magFilter]),s.texParameteri(v,10241,st[x.minFilter])):(s.texParameteri(v,10242,33071),s.texParameteri(v,10243,33071),(v===32879||v===35866)&&s.texParameteri(v,32882,33071),(x.wrapS!==we||x.wrapT!==we)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(v,10240,L(x.magFilter)),s.texParameteri(v,10241,L(x.minFilter)),x.minFilter!==ce&&x.minFilter!==ve&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const $=t.get("EXT_texture_filter_anisotropic");if(x.type===hn&&t.has("OES_texture_float_linear")===!1||a===!1&&x.type===ti&&t.has("OES_texture_half_float_linear")===!1)return;(x.anisotropy>1||n.get(x).__currentAnisotropy)&&(s.texParameterf(v,$.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(x.anisotropy,i.getMaxAnisotropy())),n.get(x).__currentAnisotropy=x.anisotropy)}}function kt(v,x){let O=!1;v.__webglInit===void 0&&(v.__webglInit=!0,x.addEventListener("dispose",G));const $=x.source;let nt=h.get($);nt===void 0&&(nt={},h.set($,nt));const at=et(x);if(at!==v.__cacheKey){nt[at]===void 0&&(nt[at]={texture:s.createTexture(),usedTimes:0},o.memory.textures++,O=!0),nt[at].usedTimes++;const bt=nt[v.__cacheKey];bt!==void 0&&(nt[v.__cacheKey].usedTimes--,bt.usedTimes===0&&F(x)),v.__cacheKey=at,v.__webglTexture=nt[at].texture}return O}function dt(v,x,O){let $=3553;(x.isDataArrayTexture||x.isCompressedArrayTexture)&&($=35866),x.isData3DTexture&&($=32879);const nt=kt(v,x),at=x.source;e.bindTexture($,v.__webglTexture,33984+O);const bt=n.get(at);if(at.version!==bt.__version||nt===!0){e.activeTexture(33984+O),s.pixelStorei(37440,x.flipY),s.pixelStorei(37441,x.premultiplyAlpha),s.pixelStorei(3317,x.unpackAlignment),s.pixelStorei(37443,0);const U=y(x)&&M(x.image)===!1;let I=T(x.image,U,!1,u);I=le(x,I);const lt=M(I)||a,ut=r.convert(x.format,x.encoding);let ot=r.convert(x.type),pt=g(x.internalFormat,ut,ot,x.encoding,x.isVideoTexture);H($,x,lt);let ft;const wt=x.mipmaps,Et=a&&x.isVideoTexture!==!0,Dt=bt.__version===void 0||nt===!0,C=w(x,I,lt);if(x.isDepthTexture)pt=6402,a?x.type===hn?pt=36012:x.type===un?pt=33190:x.type===On?pt=35056:pt=33189:x.type===hn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),x.format===dn&&pt===6402&&x.type!==sa&&x.type!==un&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),x.type=un,ot=r.convert(x.type)),x.format===Hn&&pt===6402&&(pt=34041,x.type!==On&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),x.type=On,ot=r.convert(x.type))),Dt&&(Et?e.texStorage2D(3553,1,pt,I.width,I.height):e.texImage2D(3553,0,pt,I.width,I.height,0,ut,ot,null));else if(x.isDataTexture)if(wt.length>0&&lt){Et&&Dt&&e.texStorage2D(3553,C,pt,wt[0].width,wt[0].height);for(let B=0,Q=wt.length;B<Q;B++)ft=wt[B],Et?e.texSubImage2D(3553,B,0,0,ft.width,ft.height,ut,ot,ft.data):e.texImage2D(3553,B,pt,ft.width,ft.height,0,ut,ot,ft.data);x.generateMipmaps=!1}else Et?(Dt&&e.texStorage2D(3553,C,pt,I.width,I.height),e.texSubImage2D(3553,0,0,0,I.width,I.height,ut,ot,I.data)):e.texImage2D(3553,0,pt,I.width,I.height,0,ut,ot,I.data);else if(x.isCompressedTexture)if(x.isCompressedArrayTexture){Et&&Dt&&e.texStorage3D(35866,C,pt,wt[0].width,wt[0].height,I.depth);for(let B=0,Q=wt.length;B<Q;B++)ft=wt[B],x.format!==Ee?ut!==null?Et?e.compressedTexSubImage3D(35866,B,0,0,0,ft.width,ft.height,I.depth,ut,ft.data,0,0):e.compressedTexImage3D(35866,B,pt,ft.width,ft.height,I.depth,0,ft.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Et?e.texSubImage3D(35866,B,0,0,0,ft.width,ft.height,I.depth,ut,ot,ft.data):e.texImage3D(35866,B,pt,ft.width,ft.height,I.depth,0,ut,ot,ft.data)}else{Et&&Dt&&e.texStorage2D(3553,C,pt,wt[0].width,wt[0].height);for(let B=0,Q=wt.length;B<Q;B++)ft=wt[B],x.format!==Ee?ut!==null?Et?e.compressedTexSubImage2D(3553,B,0,0,ft.width,ft.height,ut,ft.data):e.compressedTexImage2D(3553,B,pt,ft.width,ft.height,0,ft.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Et?e.texSubImage2D(3553,B,0,0,ft.width,ft.height,ut,ot,ft.data):e.texImage2D(3553,B,pt,ft.width,ft.height,0,ut,ot,ft.data)}else if(x.isDataArrayTexture)Et?(Dt&&e.texStorage3D(35866,C,pt,I.width,I.height,I.depth),e.texSubImage3D(35866,0,0,0,0,I.width,I.height,I.depth,ut,ot,I.data)):e.texImage3D(35866,0,pt,I.width,I.height,I.depth,0,ut,ot,I.data);else if(x.isData3DTexture)Et?(Dt&&e.texStorage3D(32879,C,pt,I.width,I.height,I.depth),e.texSubImage3D(32879,0,0,0,0,I.width,I.height,I.depth,ut,ot,I.data)):e.texImage3D(32879,0,pt,I.width,I.height,I.depth,0,ut,ot,I.data);else if(x.isFramebufferTexture){if(Dt)if(Et)e.texStorage2D(3553,C,pt,I.width,I.height);else{let B=I.width,Q=I.height;for(let ct=0;ct<C;ct++)e.texImage2D(3553,ct,pt,B,Q,0,ut,ot,null),B>>=1,Q>>=1}}else if(wt.length>0&&lt){Et&&Dt&&e.texStorage2D(3553,C,pt,wt[0].width,wt[0].height);for(let B=0,Q=wt.length;B<Q;B++)ft=wt[B],Et?e.texSubImage2D(3553,B,0,0,ut,ot,ft):e.texImage2D(3553,B,pt,ut,ot,ft);x.generateMipmaps=!1}else Et?(Dt&&e.texStorage2D(3553,C,pt,I.width,I.height),e.texSubImage2D(3553,0,0,0,ut,ot,I)):e.texImage2D(3553,0,pt,ut,ot,I);E(x,lt)&&P($),bt.__version=at.version,x.onUpdate&&x.onUpdate(x)}v.__version=x.version}function St(v,x,O){if(x.image.length!==6)return;const $=kt(v,x),nt=x.source;e.bindTexture(34067,v.__webglTexture,33984+O);const at=n.get(nt);if(nt.version!==at.__version||$===!0){e.activeTexture(33984+O),s.pixelStorei(37440,x.flipY),s.pixelStorei(37441,x.premultiplyAlpha),s.pixelStorei(3317,x.unpackAlignment),s.pixelStorei(37443,0);const bt=x.isCompressedTexture||x.image[0].isCompressedTexture,U=x.image[0]&&x.image[0].isDataTexture,I=[];for(let B=0;B<6;B++)!bt&&!U?I[B]=T(x.image[B],!1,!0,l):I[B]=U?x.image[B].image:x.image[B],I[B]=le(x,I[B]);const lt=I[0],ut=M(lt)||a,ot=r.convert(x.format,x.encoding),pt=r.convert(x.type),ft=g(x.internalFormat,ot,pt,x.encoding),wt=a&&x.isVideoTexture!==!0,Et=at.__version===void 0||$===!0;let Dt=w(x,lt,ut);H(34067,x,ut);let C;if(bt){wt&&Et&&e.texStorage2D(34067,Dt,ft,lt.width,lt.height);for(let B=0;B<6;B++){C=I[B].mipmaps;for(let Q=0;Q<C.length;Q++){const ct=C[Q];x.format!==Ee?ot!==null?wt?e.compressedTexSubImage2D(34069+B,Q,0,0,ct.width,ct.height,ot,ct.data):e.compressedTexImage2D(34069+B,Q,ft,ct.width,ct.height,0,ct.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):wt?e.texSubImage2D(34069+B,Q,0,0,ct.width,ct.height,ot,pt,ct.data):e.texImage2D(34069+B,Q,ft,ct.width,ct.height,0,ot,pt,ct.data)}}}else{C=x.mipmaps,wt&&Et&&(C.length>0&&Dt++,e.texStorage2D(34067,Dt,ft,I[0].width,I[0].height));for(let B=0;B<6;B++)if(U){wt?e.texSubImage2D(34069+B,0,0,0,I[B].width,I[B].height,ot,pt,I[B].data):e.texImage2D(34069+B,0,ft,I[B].width,I[B].height,0,ot,pt,I[B].data);for(let Q=0;Q<C.length;Q++){const mt=C[Q].image[B].image;wt?e.texSubImage2D(34069+B,Q+1,0,0,mt.width,mt.height,ot,pt,mt.data):e.texImage2D(34069+B,Q+1,ft,mt.width,mt.height,0,ot,pt,mt.data)}}else{wt?e.texSubImage2D(34069+B,0,0,0,ot,pt,I[B]):e.texImage2D(34069+B,0,ft,ot,pt,I[B]);for(let Q=0;Q<C.length;Q++){const ct=C[Q];wt?e.texSubImage2D(34069+B,Q+1,0,0,ot,pt,ct.image[B]):e.texImage2D(34069+B,Q+1,ft,ot,pt,ct.image[B])}}}E(x,ut)&&P(34067),at.__version=nt.version,x.onUpdate&&x.onUpdate(x)}v.__version=x.version}function ht(v,x,O,$,nt){const at=r.convert(O.format,O.encoding),bt=r.convert(O.type),U=g(O.internalFormat,at,bt,O.encoding);n.get(x).__hasExternalTextures||(nt===32879||nt===35866?e.texImage3D(nt,0,U,x.width,x.height,x.depth,0,at,bt,null):e.texImage2D(nt,0,U,x.width,x.height,0,at,bt,null)),e.bindFramebuffer(36160,v),Nt(x)?f.framebufferTexture2DMultisampleEXT(36160,$,nt,n.get(O).__webglTexture,0,Jt(x)):(nt===3553||nt>=34069&&nt<=34074)&&s.framebufferTexture2D(36160,$,nt,n.get(O).__webglTexture,0),e.bindFramebuffer(36160,null)}function Pt(v,x,O){if(s.bindRenderbuffer(36161,v),x.depthBuffer&&!x.stencilBuffer){let $=33189;if(O||Nt(x)){const nt=x.depthTexture;nt&&nt.isDepthTexture&&(nt.type===hn?$=36012:nt.type===un&&($=33190));const at=Jt(x);Nt(x)?f.renderbufferStorageMultisampleEXT(36161,at,$,x.width,x.height):s.renderbufferStorageMultisample(36161,at,$,x.width,x.height)}else s.renderbufferStorage(36161,$,x.width,x.height);s.framebufferRenderbuffer(36160,36096,36161,v)}else if(x.depthBuffer&&x.stencilBuffer){const $=Jt(x);O&&Nt(x)===!1?s.renderbufferStorageMultisample(36161,$,35056,x.width,x.height):Nt(x)?f.renderbufferStorageMultisampleEXT(36161,$,35056,x.width,x.height):s.renderbufferStorage(36161,34041,x.width,x.height),s.framebufferRenderbuffer(36160,33306,36161,v)}else{const $=x.isWebGLMultipleRenderTargets===!0?x.texture:[x.texture];for(let nt=0;nt<$.length;nt++){const at=$[nt],bt=r.convert(at.format,at.encoding),U=r.convert(at.type),I=g(at.internalFormat,bt,U,at.encoding),lt=Jt(x);O&&Nt(x)===!1?s.renderbufferStorageMultisample(36161,lt,I,x.width,x.height):Nt(x)?f.renderbufferStorageMultisampleEXT(36161,lt,I,x.width,x.height):s.renderbufferStorage(36161,I,x.width,x.height)}}s.bindRenderbuffer(36161,null)}function At(v,x){if(x&&x.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,v),!(x.depthTexture&&x.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(x.depthTexture).__webglTexture||x.depthTexture.image.width!==x.width||x.depthTexture.image.height!==x.height)&&(x.depthTexture.image.width=x.width,x.depthTexture.image.height=x.height,x.depthTexture.needsUpdate=!0),X(x.depthTexture,0);const $=n.get(x.depthTexture).__webglTexture,nt=Jt(x);if(x.depthTexture.format===dn)Nt(x)?f.framebufferTexture2DMultisampleEXT(36160,36096,3553,$,0,nt):s.framebufferTexture2D(36160,36096,3553,$,0);else if(x.depthTexture.format===Hn)Nt(x)?f.framebufferTexture2DMultisampleEXT(36160,33306,3553,$,0,nt):s.framebufferTexture2D(36160,33306,3553,$,0);else throw new Error("Unknown depthTexture format")}function xt(v){const x=n.get(v),O=v.isWebGLCubeRenderTarget===!0;if(v.depthTexture&&!x.__autoAllocateDepthBuffer){if(O)throw new Error("target.depthTexture not supported in Cube render targets");At(x.__webglFramebuffer,v)}else if(O){x.__webglDepthbuffer=[];for(let $=0;$<6;$++)e.bindFramebuffer(36160,x.__webglFramebuffer[$]),x.__webglDepthbuffer[$]=s.createRenderbuffer(),Pt(x.__webglDepthbuffer[$],v,!1)}else e.bindFramebuffer(36160,x.__webglFramebuffer),x.__webglDepthbuffer=s.createRenderbuffer(),Pt(x.__webglDepthbuffer,v,!1);e.bindFramebuffer(36160,null)}function Zt(v,x,O){const $=n.get(v);x!==void 0&&ht($.__webglFramebuffer,v,v.texture,36064,3553),O!==void 0&&xt(v)}function Wt(v){const x=v.texture,O=n.get(v),$=n.get(x);v.addEventListener("dispose",rt),v.isWebGLMultipleRenderTargets!==!0&&($.__webglTexture===void 0&&($.__webglTexture=s.createTexture()),$.__version=x.version,o.memory.textures++);const nt=v.isWebGLCubeRenderTarget===!0,at=v.isWebGLMultipleRenderTargets===!0,bt=M(v)||a;if(nt){O.__webglFramebuffer=[];for(let U=0;U<6;U++)O.__webglFramebuffer[U]=s.createFramebuffer()}else{if(O.__webglFramebuffer=s.createFramebuffer(),at)if(i.drawBuffers){const U=v.texture;for(let I=0,lt=U.length;I<lt;I++){const ut=n.get(U[I]);ut.__webglTexture===void 0&&(ut.__webglTexture=s.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&v.samples>0&&Nt(v)===!1){const U=at?x:[x];O.__webglMultisampledFramebuffer=s.createFramebuffer(),O.__webglColorRenderbuffer=[],e.bindFramebuffer(36160,O.__webglMultisampledFramebuffer);for(let I=0;I<U.length;I++){const lt=U[I];O.__webglColorRenderbuffer[I]=s.createRenderbuffer(),s.bindRenderbuffer(36161,O.__webglColorRenderbuffer[I]);const ut=r.convert(lt.format,lt.encoding),ot=r.convert(lt.type),pt=g(lt.internalFormat,ut,ot,lt.encoding,v.isXRRenderTarget===!0),ft=Jt(v);s.renderbufferStorageMultisample(36161,ft,pt,v.width,v.height),s.framebufferRenderbuffer(36160,36064+I,36161,O.__webglColorRenderbuffer[I])}s.bindRenderbuffer(36161,null),v.depthBuffer&&(O.__webglDepthRenderbuffer=s.createRenderbuffer(),Pt(O.__webglDepthRenderbuffer,v,!0)),e.bindFramebuffer(36160,null)}}if(nt){e.bindTexture(34067,$.__webglTexture),H(34067,x,bt);for(let U=0;U<6;U++)ht(O.__webglFramebuffer[U],v,x,36064,34069+U);E(x,bt)&&P(34067),e.unbindTexture()}else if(at){const U=v.texture;for(let I=0,lt=U.length;I<lt;I++){const ut=U[I],ot=n.get(ut);e.bindTexture(3553,ot.__webglTexture),H(3553,ut,bt),ht(O.__webglFramebuffer,v,ut,36064+I,3553),E(ut,bt)&&P(3553)}e.unbindTexture()}else{let U=3553;(v.isWebGL3DRenderTarget||v.isWebGLArrayRenderTarget)&&(a?U=v.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),e.bindTexture(U,$.__webglTexture),H(U,x,bt),ht(O.__webglFramebuffer,v,x,36064,U),E(x,bt)&&P(U),e.unbindTexture()}v.depthBuffer&&xt(v)}function qt(v){const x=M(v)||a,O=v.isWebGLMultipleRenderTargets===!0?v.texture:[v.texture];for(let $=0,nt=O.length;$<nt;$++){const at=O[$];if(E(at,x)){const bt=v.isWebGLCubeRenderTarget?34067:3553,U=n.get(at).__webglTexture;e.bindTexture(bt,U),P(bt),e.unbindTexture()}}}function re(v){if(a&&v.samples>0&&Nt(v)===!1){const x=v.isWebGLMultipleRenderTargets?v.texture:[v.texture],O=v.width,$=v.height;let nt=16384;const at=[],bt=v.stencilBuffer?33306:36096,U=n.get(v),I=v.isWebGLMultipleRenderTargets===!0;if(I)for(let lt=0;lt<x.length;lt++)e.bindFramebuffer(36160,U.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+lt,36161,null),e.bindFramebuffer(36160,U.__webglFramebuffer),s.framebufferTexture2D(36009,36064+lt,3553,null,0);e.bindFramebuffer(36008,U.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,U.__webglFramebuffer);for(let lt=0;lt<x.length;lt++){at.push(36064+lt),v.depthBuffer&&at.push(bt);const ut=U.__ignoreDepthValues!==void 0?U.__ignoreDepthValues:!1;if(ut===!1&&(v.depthBuffer&&(nt|=256),v.stencilBuffer&&(nt|=1024)),I&&s.framebufferRenderbuffer(36008,36064,36161,U.__webglColorRenderbuffer[lt]),ut===!0&&(s.invalidateFramebuffer(36008,[bt]),s.invalidateFramebuffer(36009,[bt])),I){const ot=n.get(x[lt]).__webglTexture;s.framebufferTexture2D(36009,36064,3553,ot,0)}s.blitFramebuffer(0,0,O,$,0,0,O,$,nt,9728),m&&s.invalidateFramebuffer(36008,at)}if(e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,null),I)for(let lt=0;lt<x.length;lt++){e.bindFramebuffer(36160,U.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+lt,36161,U.__webglColorRenderbuffer[lt]);const ut=n.get(x[lt]).__webglTexture;e.bindFramebuffer(36160,U.__webglFramebuffer),s.framebufferTexture2D(36009,36064+lt,3553,ut,0)}e.bindFramebuffer(36009,U.__webglMultisampledFramebuffer)}}function Jt(v){return Math.min(d,v.samples)}function Nt(v){const x=n.get(v);return a&&v.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&x.__useRenderToTexture!==!1}function be(v){const x=o.render.frame;b.get(v)!==x&&(b.set(v,x),v.update())}function le(v,x){const O=v.encoding,$=v.format,nt=v.type;return v.isCompressedTexture===!0||v.isVideoTexture===!0||v.format===Ur||O!==mn&&(O===Ot?a===!1?t.has("EXT_sRGB")===!0&&$===Ee?(v.format=Ur,v.minFilter=ve,v.generateMipmaps=!1):x=ca.sRGBToLinear(x):($!==Ee||nt!==pn)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",O)),x}this.allocateTextureUnit=q,this.resetTextureUnits=z,this.setTexture2D=X,this.setTexture2DArray=K,this.setTexture3D=_,this.setTextureCube=Y,this.rebindTextures=Zt,this.setupRenderTarget=Wt,this.updateRenderTargetMipmap=qt,this.updateMultisampleRenderTarget=re,this.setupDepthRenderbuffer=xt,this.setupFrameBufferTexture=ht,this.useMultisampledRTT=Nt}function bd(s,t,e){const n=e.isWebGL2;function i(r,o=null){let a;if(r===pn)return 5121;if(r===co)return 32819;if(r===uo)return 32820;if(r===ao)return 5120;if(r===oo)return 5122;if(r===sa)return 5123;if(r===lo)return 5124;if(r===un)return 5125;if(r===hn)return 5126;if(r===ti)return n?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(r===ho)return 6406;if(r===Ee)return 6408;if(r===po)return 6409;if(r===mo)return 6410;if(r===dn)return 6402;if(r===Hn)return 34041;if(r===fo)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(r===Ur)return a=t.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(r===go)return 6403;if(r===So)return 36244;if(r===xo)return 33319;if(r===bo)return 33320;if(r===yo)return 36249;if(r===Ji||r===Bi||r===_i||r===Hi)if(o===Ot)if(a=t.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(r===Ji)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Bi)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===_i)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===Hi)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(r===Ji)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Bi)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===_i)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Hi)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===qr||r===Gr||r===jr||r===zr)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(r===qr)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===Gr)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===jr)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===zr)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===Ao)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===Qr||r===Zr)if(a=t.get("WEBGL_compressed_texture_etc"),a!==null){if(r===Qr)return o===Ot?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(r===Zr)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===Yr||r===Xr||r===$r||r===ts||r===es||r===ns||r===is||r===rs||r===ss||r===as||r===os||r===ls||r===cs||r===us)if(a=t.get("WEBGL_compressed_texture_astc"),a!==null){if(r===Yr)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===Xr)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===$r)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===ts)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===es)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===ns)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===is)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===rs)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===ss)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===as)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===os)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===ls)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===cs)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===us)return o===Ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===hs)if(a=t.get("EXT_texture_compression_bptc"),a!==null){if(r===hs)return o===Ot?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return r===On?n?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):s[r]!==void 0?s[r]:null}return{convert:i}}class yd extends Se{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class Ci extends ie{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Ad={type:"move"};class xr{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ci,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ci,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new N,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new N),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ci,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new N,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new N),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,o=null;const a=this._targetRay,c=this._grip,l=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(l&&t.hand){o=!0;for(const p of t.hand.values()){const h=e.getJointPose(p,n),S=this._getHandJoint(l,p);h!==null&&(S.matrix.fromArray(h.transform.matrix),S.matrix.decompose(S.position,S.rotation,S.scale),S.jointRadius=h.radius),S.visible=h!==null}const u=l.joints["index-finger-tip"],d=l.joints["thumb-tip"],f=u.position.distanceTo(d.position),m=.02,b=.005;l.inputState.pinching&&f>m+b?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&f<=m-b&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else c!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),r!==null&&(c.matrix.fromArray(r.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),r.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(r.linearVelocity)):c.hasLinearVelocity=!1,r.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(r.angularVelocity)):c.hasAngularVelocity=!1));a!==null&&(i=e.getPose(t.targetRaySpace,n),i===null&&r!==null&&(i=r),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Ad)))}return a!==null&&(a.visible=i!==null),c!==null&&(c.visible=r!==null),l!==null&&(l.visible=o!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new Ci;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class vd extends he{constructor(t,e,n,i,r,o,a,c,l,u){if(u=u!==void 0?u:dn,u!==dn&&u!==Hn)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===dn&&(n=un),n===void 0&&u===Hn&&(n=On),super(null,i,r,o,a,c,u,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=a!==void 0?a:ce,this.minFilter=c!==void 0?c:ce,this.flipY=!1,this.generateMipmaps=!1}}class Md extends bn{constructor(t,e){super();const n=this;let i=null,r=1,o=null,a="local-floor",c=null,l=null,u=null,d=null,f=null,m=null;const b=e.getContextAttributes();let p=null,h=null;const S=[],k=[],T=new Set,M=new Map,y=new Se;y.layers.enable(1),y.viewport=new te;const E=new Se;E.layers.enable(2),E.viewport=new te;const P=[y,E],g=new yd;g.layers.enable(1),g.layers.enable(2);let w=null,L=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(K){let _=S[K];return _===void 0&&(_=new xr,S[K]=_),_.getTargetRaySpace()},this.getControllerGrip=function(K){let _=S[K];return _===void 0&&(_=new xr,S[K]=_),_.getGripSpace()},this.getHand=function(K){let _=S[K];return _===void 0&&(_=new xr,S[K]=_),_.getHandSpace()};function G(K){const _=k.indexOf(K.inputSource);if(_===-1)return;const Y=S[_];Y!==void 0&&Y.dispatchEvent({type:K.type,data:K.inputSource})}function rt(){i.removeEventListener("select",G),i.removeEventListener("selectstart",G),i.removeEventListener("selectend",G),i.removeEventListener("squeeze",G),i.removeEventListener("squeezestart",G),i.removeEventListener("squeezeend",G),i.removeEventListener("end",rt),i.removeEventListener("inputsourceschange",V);for(let K=0;K<S.length;K++){const _=k[K];_!==null&&(k[K]=null,S[K].disconnect(_))}w=null,L=null,t.setRenderTarget(p),f=null,d=null,u=null,i=null,h=null,X.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(K){r=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(K){a=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(K){c=K},this.getBaseLayer=function(){return d!==null?d:f},this.getBinding=function(){return u},this.getFrame=function(){return m},this.getSession=function(){return i},this.setSession=async function(K){if(i=K,i!==null){if(p=t.getRenderTarget(),i.addEventListener("select",G),i.addEventListener("selectstart",G),i.addEventListener("selectend",G),i.addEventListener("squeeze",G),i.addEventListener("squeezestart",G),i.addEventListener("squeezeend",G),i.addEventListener("end",rt),i.addEventListener("inputsourceschange",V),b.xrCompatible!==!0&&await e.makeXRCompatible(),i.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const _={antialias:i.renderState.layers===void 0?b.antialias:!0,alpha:b.alpha,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:r};f=new XRWebGLLayer(i,e,_),i.updateRenderState({baseLayer:f}),h=new gn(f.framebufferWidth,f.framebufferHeight,{format:Ee,type:pn,encoding:t.outputEncoding,stencilBuffer:b.stencil})}else{let _=null,Y=null,tt=null;b.depth&&(tt=b.stencil?35056:33190,_=b.stencil?Hn:dn,Y=b.stencil?On:un);const st={colorFormat:32856,depthFormat:tt,scaleFactor:r};u=new XRWebGLBinding(i,e),d=u.createProjectionLayer(st),i.updateRenderState({layers:[d]}),h=new gn(d.textureWidth,d.textureHeight,{format:Ee,type:pn,depthTexture:new vd(d.textureWidth,d.textureHeight,Y,void 0,void 0,void 0,void 0,void 0,void 0,_),stencilBuffer:b.stencil,encoding:t.outputEncoding,samples:b.antialias?4:0});const H=t.properties.get(h);H.__ignoreDepthValues=d.ignoreDepthValues}h.isXRRenderTarget=!0,this.setFoveation(1),c=null,o=await i.requestReferenceSpace(a),X.setContext(i),X.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function V(K){for(let _=0;_<K.removed.length;_++){const Y=K.removed[_],tt=k.indexOf(Y);tt>=0&&(k[tt]=null,S[tt].disconnect(Y))}for(let _=0;_<K.added.length;_++){const Y=K.added[_];let tt=k.indexOf(Y);if(tt===-1){for(let H=0;H<S.length;H++)if(H>=k.length){k.push(Y),tt=H;break}else if(k[H]===null){k[H]=Y,tt=H;break}if(tt===-1)break}const st=S[tt];st&&st.connect(Y)}}const F=new N,j=new N;function Z(K,_,Y){F.setFromMatrixPosition(_.matrixWorld),j.setFromMatrixPosition(Y.matrixWorld);const tt=F.distanceTo(j),st=_.projectionMatrix.elements,H=Y.projectionMatrix.elements,kt=st[14]/(st[10]-1),dt=st[14]/(st[10]+1),St=(st[9]+1)/st[5],ht=(st[9]-1)/st[5],Pt=(st[8]-1)/st[0],At=(H[8]+1)/H[0],xt=kt*Pt,Zt=kt*At,Wt=tt/(-Pt+At),qt=Wt*-Pt;_.matrixWorld.decompose(K.position,K.quaternion,K.scale),K.translateX(qt),K.translateZ(Wt),K.matrixWorld.compose(K.position,K.quaternion,K.scale),K.matrixWorldInverse.copy(K.matrixWorld).invert();const re=kt+Wt,Jt=dt+Wt,Nt=xt-qt,be=Zt+(tt-qt),le=St*dt/Jt*re,v=ht*dt/Jt*re;K.projectionMatrix.makePerspective(Nt,be,le,v,re,Jt)}function z(K,_){_===null?K.matrixWorld.copy(K.matrix):K.matrixWorld.multiplyMatrices(_.matrixWorld,K.matrix),K.matrixWorldInverse.copy(K.matrixWorld).invert()}this.updateCamera=function(K){if(i===null)return;g.near=E.near=y.near=K.near,g.far=E.far=y.far=K.far,(w!==g.near||L!==g.far)&&(i.updateRenderState({depthNear:g.near,depthFar:g.far}),w=g.near,L=g.far);const _=K.parent,Y=g.cameras;z(g,_);for(let st=0;st<Y.length;st++)z(Y[st],_);g.matrixWorld.decompose(g.position,g.quaternion,g.scale),K.matrix.copy(g.matrix),K.matrix.decompose(K.position,K.quaternion,K.scale);const tt=K.children;for(let st=0,H=tt.length;st<H;st++)tt[st].updateMatrixWorld(!0);Y.length===2?Z(g,y,E):g.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return g},this.getFoveation=function(){if(d!==null)return d.fixedFoveation;if(f!==null)return f.fixedFoveation},this.setFoveation=function(K){d!==null&&(d.fixedFoveation=K),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=K)},this.getPlanes=function(){return T};let q=null;function et(K,_){if(l=_.getViewerPose(c||o),m=_,l!==null){const Y=l.views;f!==null&&(t.setRenderTargetFramebuffer(h,f.framebuffer),t.setRenderTarget(h));let tt=!1;Y.length!==g.cameras.length&&(g.cameras.length=0,tt=!0);for(let st=0;st<Y.length;st++){const H=Y[st];let kt=null;if(f!==null)kt=f.getViewport(H);else{const St=u.getViewSubImage(d,H);kt=St.viewport,st===0&&(t.setRenderTargetTextures(h,St.colorTexture,d.ignoreDepthValues?void 0:St.depthStencilTexture),t.setRenderTarget(h))}let dt=P[st];dt===void 0&&(dt=new Se,dt.layers.enable(st),dt.viewport=new te,P[st]=dt),dt.matrix.fromArray(H.transform.matrix),dt.projectionMatrix.fromArray(H.projectionMatrix),dt.viewport.set(kt.x,kt.y,kt.width,kt.height),st===0&&g.matrix.copy(dt.matrix),tt===!0&&g.cameras.push(dt)}}for(let Y=0;Y<S.length;Y++){const tt=k[Y],st=S[Y];tt!==null&&st!==void 0&&st.update(tt,_,c||o)}if(q&&q(K,_),_.detectedPlanes){n.dispatchEvent({type:"planesdetected",data:_.detectedPlanes});let Y=null;for(const tt of T)_.detectedPlanes.has(tt)||(Y===null&&(Y=[]),Y.push(tt));if(Y!==null)for(const tt of Y)T.delete(tt),M.delete(tt),n.dispatchEvent({type:"planeremoved",data:tt});for(const tt of _.detectedPlanes)if(!T.has(tt))T.add(tt),M.set(tt,_.lastChangedTime),n.dispatchEvent({type:"planeadded",data:tt});else{const st=M.get(tt);tt.lastChangedTime>st&&(M.set(tt,tt.lastChangedTime),n.dispatchEvent({type:"planechanged",data:tt}))}}m=null}const X=new ba;X.setAnimationLoop(et),this.setAnimationLoop=function(K){q=K},this.dispose=function(){}}}function Td(s,t){function e(p,h){h.color.getRGB(p.fogColor.value,ga(s)),h.isFog?(p.fogNear.value=h.near,p.fogFar.value=h.far):h.isFogExp2&&(p.fogDensity.value=h.density)}function n(p,h,S,k,T){h.isMeshBasicMaterial||h.isMeshLambertMaterial?i(p,h):h.isMeshToonMaterial?(i(p,h),u(p,h)):h.isMeshPhongMaterial?(i(p,h),l(p,h)):h.isMeshStandardMaterial?(i(p,h),d(p,h),h.isMeshPhysicalMaterial&&f(p,h,T)):h.isMeshMatcapMaterial?(i(p,h),m(p,h)):h.isMeshDepthMaterial?i(p,h):h.isMeshDistanceMaterial?(i(p,h),b(p,h)):h.isMeshNormalMaterial?i(p,h):h.isLineBasicMaterial?(r(p,h),h.isLineDashedMaterial&&o(p,h)):h.isPointsMaterial?a(p,h,S,k):h.isSpriteMaterial?c(p,h):h.isShadowMaterial?(p.color.value.copy(h.color),p.opacity.value=h.opacity):h.isShaderMaterial&&(h.uniformsNeedUpdate=!1)}function i(p,h){p.opacity.value=h.opacity,h.color&&p.diffuse.value.copy(h.color),h.emissive&&p.emissive.value.copy(h.emissive).multiplyScalar(h.emissiveIntensity),h.map&&(p.map.value=h.map),h.alphaMap&&(p.alphaMap.value=h.alphaMap),h.bumpMap&&(p.bumpMap.value=h.bumpMap,p.bumpScale.value=h.bumpScale,h.side===Me&&(p.bumpScale.value*=-1)),h.displacementMap&&(p.displacementMap.value=h.displacementMap,p.displacementScale.value=h.displacementScale,p.displacementBias.value=h.displacementBias),h.emissiveMap&&(p.emissiveMap.value=h.emissiveMap),h.normalMap&&(p.normalMap.value=h.normalMap,p.normalScale.value.copy(h.normalScale),h.side===Me&&p.normalScale.value.negate()),h.specularMap&&(p.specularMap.value=h.specularMap),h.alphaTest>0&&(p.alphaTest.value=h.alphaTest);const S=t.get(h).envMap;if(S&&(p.envMap.value=S,p.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=h.reflectivity,p.ior.value=h.ior,p.refractionRatio.value=h.refractionRatio),h.lightMap){p.lightMap.value=h.lightMap;const M=s.physicallyCorrectLights!==!0?Math.PI:1;p.lightMapIntensity.value=h.lightMapIntensity*M}h.aoMap&&(p.aoMap.value=h.aoMap,p.aoMapIntensity.value=h.aoMapIntensity);let k;h.map?k=h.map:h.specularMap?k=h.specularMap:h.displacementMap?k=h.displacementMap:h.normalMap?k=h.normalMap:h.bumpMap?k=h.bumpMap:h.roughnessMap?k=h.roughnessMap:h.metalnessMap?k=h.metalnessMap:h.alphaMap?k=h.alphaMap:h.emissiveMap?k=h.emissiveMap:h.clearcoatMap?k=h.clearcoatMap:h.clearcoatNormalMap?k=h.clearcoatNormalMap:h.clearcoatRoughnessMap?k=h.clearcoatRoughnessMap:h.iridescenceMap?k=h.iridescenceMap:h.iridescenceThicknessMap?k=h.iridescenceThicknessMap:h.specularIntensityMap?k=h.specularIntensityMap:h.specularColorMap?k=h.specularColorMap:h.transmissionMap?k=h.transmissionMap:h.thicknessMap?k=h.thicknessMap:h.sheenColorMap?k=h.sheenColorMap:h.sheenRoughnessMap&&(k=h.sheenRoughnessMap),k!==void 0&&(k.isWebGLRenderTarget&&(k=k.texture),k.matrixAutoUpdate===!0&&k.updateMatrix(),p.uvTransform.value.copy(k.matrix));let T;h.aoMap?T=h.aoMap:h.lightMap&&(T=h.lightMap),T!==void 0&&(T.isWebGLRenderTarget&&(T=T.texture),T.matrixAutoUpdate===!0&&T.updateMatrix(),p.uv2Transform.value.copy(T.matrix))}function r(p,h){p.diffuse.value.copy(h.color),p.opacity.value=h.opacity}function o(p,h){p.dashSize.value=h.dashSize,p.totalSize.value=h.dashSize+h.gapSize,p.scale.value=h.scale}function a(p,h,S,k){p.diffuse.value.copy(h.color),p.opacity.value=h.opacity,p.size.value=h.size*S,p.scale.value=k*.5,h.map&&(p.map.value=h.map),h.alphaMap&&(p.alphaMap.value=h.alphaMap),h.alphaTest>0&&(p.alphaTest.value=h.alphaTest);let T;h.map?T=h.map:h.alphaMap&&(T=h.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),p.uvTransform.value.copy(T.matrix))}function c(p,h){p.diffuse.value.copy(h.color),p.opacity.value=h.opacity,p.rotation.value=h.rotation,h.map&&(p.map.value=h.map),h.alphaMap&&(p.alphaMap.value=h.alphaMap),h.alphaTest>0&&(p.alphaTest.value=h.alphaTest);let S;h.map?S=h.map:h.alphaMap&&(S=h.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),p.uvTransform.value.copy(S.matrix))}function l(p,h){p.specular.value.copy(h.specular),p.shininess.value=Math.max(h.shininess,1e-4)}function u(p,h){h.gradientMap&&(p.gradientMap.value=h.gradientMap)}function d(p,h){p.roughness.value=h.roughness,p.metalness.value=h.metalness,h.roughnessMap&&(p.roughnessMap.value=h.roughnessMap),h.metalnessMap&&(p.metalnessMap.value=h.metalnessMap),t.get(h).envMap&&(p.envMapIntensity.value=h.envMapIntensity)}function f(p,h,S){p.ior.value=h.ior,h.sheen>0&&(p.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen),p.sheenRoughness.value=h.sheenRoughness,h.sheenColorMap&&(p.sheenColorMap.value=h.sheenColorMap),h.sheenRoughnessMap&&(p.sheenRoughnessMap.value=h.sheenRoughnessMap)),h.clearcoat>0&&(p.clearcoat.value=h.clearcoat,p.clearcoatRoughness.value=h.clearcoatRoughness,h.clearcoatMap&&(p.clearcoatMap.value=h.clearcoatMap),h.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=h.clearcoatRoughnessMap),h.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),p.clearcoatNormalMap.value=h.clearcoatNormalMap,h.side===Me&&p.clearcoatNormalScale.value.negate())),h.iridescence>0&&(p.iridescence.value=h.iridescence,p.iridescenceIOR.value=h.iridescenceIOR,p.iridescenceThicknessMinimum.value=h.iridescenceThicknessRange[0],p.iridescenceThicknessMaximum.value=h.iridescenceThicknessRange[1],h.iridescenceMap&&(p.iridescenceMap.value=h.iridescenceMap),h.iridescenceThicknessMap&&(p.iridescenceThicknessMap.value=h.iridescenceThicknessMap)),h.transmission>0&&(p.transmission.value=h.transmission,p.transmissionSamplerMap.value=S.texture,p.transmissionSamplerSize.value.set(S.width,S.height),h.transmissionMap&&(p.transmissionMap.value=h.transmissionMap),p.thickness.value=h.thickness,h.thicknessMap&&(p.thicknessMap.value=h.thicknessMap),p.attenuationDistance.value=h.attenuationDistance,p.attenuationColor.value.copy(h.attenuationColor)),p.specularIntensity.value=h.specularIntensity,p.specularColor.value.copy(h.specularColor),h.specularIntensityMap&&(p.specularIntensityMap.value=h.specularIntensityMap),h.specularColorMap&&(p.specularColorMap.value=h.specularColorMap)}function m(p,h){h.matcap&&(p.matcap.value=h.matcap)}function b(p,h){p.referencePosition.value.copy(h.referencePosition),p.nearDistance.value=h.nearDistance,p.farDistance.value=h.farDistance}return{refreshFogUniforms:e,refreshMaterialUniforms:n}}function Ud(s,t,e,n){let i={},r={},o=[];const a=e.isWebGL2?s.getParameter(35375):0;function c(k,T){const M=T.program;n.uniformBlockBinding(k,M)}function l(k,T){let M=i[k.id];M===void 0&&(b(k),M=u(k),i[k.id]=M,k.addEventListener("dispose",h));const y=T.program;n.updateUBOMapping(k,y);const E=t.render.frame;r[k.id]!==E&&(f(k),r[k.id]=E)}function u(k){const T=d();k.__bindingPointIndex=T;const M=s.createBuffer(),y=k.__size,E=k.usage;return s.bindBuffer(35345,M),s.bufferData(35345,y,E),s.bindBuffer(35345,null),s.bindBufferBase(35345,T,M),M}function d(){for(let k=0;k<a;k++)if(o.indexOf(k)===-1)return o.push(k),k;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function f(k){const T=i[k.id],M=k.uniforms,y=k.__cache;s.bindBuffer(35345,T);for(let E=0,P=M.length;E<P;E++){const g=M[E];if(m(g,E,y)===!0){const w=g.value,L=g.__offset;typeof w=="number"?(g.__data[0]=w,s.bufferSubData(35345,L,g.__data)):(g.value.isMatrix3?(g.__data[0]=g.value.elements[0],g.__data[1]=g.value.elements[1],g.__data[2]=g.value.elements[2],g.__data[3]=g.value.elements[0],g.__data[4]=g.value.elements[3],g.__data[5]=g.value.elements[4],g.__data[6]=g.value.elements[5],g.__data[7]=g.value.elements[0],g.__data[8]=g.value.elements[6],g.__data[9]=g.value.elements[7],g.__data[10]=g.value.elements[8],g.__data[11]=g.value.elements[0]):w.toArray(g.__data),s.bufferSubData(35345,L,g.__data))}}s.bindBuffer(35345,null)}function m(k,T,M){const y=k.value;if(M[T]===void 0)return typeof y=="number"?M[T]=y:M[T]=y.clone(),!0;if(typeof y=="number"){if(M[T]!==y)return M[T]=y,!0}else{const E=M[T];if(E.equals(y)===!1)return E.copy(y),!0}return!1}function b(k){const T=k.uniforms;let M=0;const y=16;let E=0;for(let P=0,g=T.length;P<g;P++){const w=T[P],L=p(w);if(w.__data=new Float32Array(L.storage/Float32Array.BYTES_PER_ELEMENT),w.__offset=M,P>0){E=M%y;const G=y-E;E!==0&&G-L.boundary<0&&(M+=y-E,w.__offset=M)}M+=L.storage}return E=M%y,E>0&&(M+=y-E),k.__size=M,k.__cache={},this}function p(k){const T=k.value,M={boundary:0,storage:0};return typeof T=="number"?(M.boundary=4,M.storage=4):T.isVector2?(M.boundary=8,M.storage=8):T.isVector3||T.isColor?(M.boundary=16,M.storage=12):T.isVector4?(M.boundary=16,M.storage=16):T.isMatrix3?(M.boundary=48,M.storage=48):T.isMatrix4?(M.boundary=64,M.storage=64):T.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",T),M}function h(k){const T=k.target;T.removeEventListener("dispose",h);const M=o.indexOf(T.__bindingPointIndex);o.splice(M,1),s.deleteBuffer(i[T.id]),delete i[T.id],delete r[T.id]}function S(){for(const k in i)s.deleteBuffer(i[k]);o=[],i={},r={}}return{bind:c,update:l,dispose:S}}function kd(){const s=ni("canvas");return s.style.display="block",s}function Ta(s={}){this.isWebGLRenderer=!0;const t=s.canvas!==void 0?s.canvas:kd(),e=s.context!==void 0?s.context:null,n=s.depth!==void 0?s.depth:!0,i=s.stencil!==void 0?s.stencil:!0,r=s.antialias!==void 0?s.antialias:!1,o=s.premultipliedAlpha!==void 0?s.premultipliedAlpha:!0,a=s.preserveDrawingBuffer!==void 0?s.preserveDrawingBuffer:!1,c=s.powerPreference!==void 0?s.powerPreference:"default",l=s.failIfMajorPerformanceCaveat!==void 0?s.failIfMajorPerformanceCaveat:!1;let u;e!==null?u=e.getContextAttributes().alpha:u=s.alpha!==void 0?s.alpha:!1;let d=null,f=null;const m=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=mn,this.physicallyCorrectLights=!1,this.toneMapping=He,this.toneMappingExposure=1;const p=this;let h=!1,S=0,k=0,T=null,M=-1,y=null;const E=new te,P=new te;let g=null,w=t.width,L=t.height,G=1,rt=null,V=null;const F=new te(0,0,w,L),j=new te(0,0,w,L);let Z=!1;const z=new Lr;let q=!1,et=!1,X=null;const K=new jt,_=new Mt,Y=new N,tt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function st(){return T===null?G:1}let H=e;function kt(A,D){for(let J=0;J<A.length;J++){const R=A[J],W=t.getContext(R,D);if(W!==null)return W}return null}try{const A={alpha:!0,depth:n,stencil:i,antialias:r,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:c,failIfMajorPerformanceCaveat:l};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Cr}`),t.addEventListener("webglcontextlost",pt,!1),t.addEventListener("webglcontextrestored",ft,!1),t.addEventListener("webglcontextcreationerror",wt,!1),H===null){const D=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&D.shift(),H=kt(D,A),H===null)throw kt(D)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}H.getShaderPrecisionFormat===void 0&&(H.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(A){throw console.error("THREE.WebGLRenderer: "+A.message),A}let dt,St,ht,Pt,At,xt,Zt,Wt,qt,re,Jt,Nt,be,le,v,x,O,$,nt,at,bt,U,I,lt;function ut(){dt=new Vu(H),St=new Iu(H,dt,s),dt.init(St),U=new bd(H,dt,St),ht=new Sd(H,dt,St),Pt=new Ju,At=new id,xt=new xd(H,dt,ht,At,St,U,Pt),Zt=new Ru(p),Wt=new Du(p),qt=new zo(H,St),I=new Eu(H,dt,qt,St),re=new Ku(H,qt,Pt,I),Jt=new Wu(H,re,qt,Pt),nt=new Hu(H,St,xt),x=new Lu(At),Nt=new nd(p,Zt,Wt,dt,St,I,x),be=new Td(p,At),le=new sd,v=new hd(dt,St),$=new wu(p,Zt,Wt,ht,Jt,u,o),O=new gd(p,Jt,St),lt=new Ud(H,Pt,St,ht),at=new Cu(H,dt,Pt,St),bt=new Ou(H,dt,Pt,St),Pt.programs=Nt.programs,p.capabilities=St,p.extensions=dt,p.properties=At,p.renderLists=le,p.shadowMap=O,p.state=ht,p.info=Pt}ut();const ot=new Md(p,H);this.xr=ot,this.getContext=function(){return H},this.getContextAttributes=function(){return H.getContextAttributes()},this.forceContextLoss=function(){const A=dt.get("WEBGL_lose_context");A&&A.loseContext()},this.forceContextRestore=function(){const A=dt.get("WEBGL_lose_context");A&&A.restoreContext()},this.getPixelRatio=function(){return G},this.setPixelRatio=function(A){A!==void 0&&(G=A,this.setSize(w,L,!1))},this.getSize=function(A){return A.set(w,L)},this.setSize=function(A,D,J){if(ot.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}w=A,L=D,t.width=Math.floor(A*G),t.height=Math.floor(D*G),J!==!1&&(t.style.width=A+"px",t.style.height=D+"px"),this.setViewport(0,0,A,D)},this.getDrawingBufferSize=function(A){return A.set(w*G,L*G).floor()},this.setDrawingBufferSize=function(A,D,J){w=A,L=D,G=J,t.width=Math.floor(A*J),t.height=Math.floor(D*J),this.setViewport(0,0,A,D)},this.getCurrentViewport=function(A){return A.copy(E)},this.getViewport=function(A){return A.copy(F)},this.setViewport=function(A,D,J,R){A.isVector4?F.set(A.x,A.y,A.z,A.w):F.set(A,D,J,R),ht.viewport(E.copy(F).multiplyScalar(G).floor())},this.getScissor=function(A){return A.copy(j)},this.setScissor=function(A,D,J,R){A.isVector4?j.set(A.x,A.y,A.z,A.w):j.set(A,D,J,R),ht.scissor(P.copy(j).multiplyScalar(G).floor())},this.getScissorTest=function(){return Z},this.setScissorTest=function(A){ht.setScissorTest(Z=A)},this.setOpaqueSort=function(A){rt=A},this.setTransparentSort=function(A){V=A},this.getClearColor=function(A){return A.copy($.getClearColor())},this.setClearColor=function(){$.setClearColor.apply($,arguments)},this.getClearAlpha=function(){return $.getClearAlpha()},this.setClearAlpha=function(){$.setClearAlpha.apply($,arguments)},this.clear=function(A=!0,D=!0,J=!0){let R=0;A&&(R|=16384),D&&(R|=256),J&&(R|=1024),H.clear(R)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",pt,!1),t.removeEventListener("webglcontextrestored",ft,!1),t.removeEventListener("webglcontextcreationerror",wt,!1),le.dispose(),v.dispose(),At.dispose(),Zt.dispose(),Wt.dispose(),Jt.dispose(),I.dispose(),lt.dispose(),Nt.dispose(),ot.dispose(),ot.removeEventListener("sessionstart",ct),ot.removeEventListener("sessionend",mt),X&&(X.dispose(),X=null),Ft.stop()};function pt(A){A.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),h=!0}function ft(){console.log("THREE.WebGLRenderer: Context Restored."),h=!1;const A=Pt.autoReset,D=O.enabled,J=O.autoUpdate,R=O.needsUpdate,W=O.type;ut(),Pt.autoReset=A,O.enabled=D,O.autoUpdate=J,O.needsUpdate=R,O.type=W}function wt(A){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",A.statusMessage)}function Et(A){const D=A.target;D.removeEventListener("dispose",Et),Dt(D)}function Dt(A){C(A),At.remove(A)}function C(A){const D=At.get(A).programs;D!==void 0&&(D.forEach(function(J){Nt.releaseProgram(J)}),A.isShaderMaterial&&Nt.releaseShaderCache(A))}this.renderBufferDirect=function(A,D,J,R,W,gt){D===null&&(D=tt);const yt=W.isMesh&&W.matrixWorld.determinant()<0,Tt=ka(A,D,J,R,W);ht.setMaterial(R,yt);let Ut=J.index,Rt=1;R.wireframe===!0&&(Ut=re.getWireframeAttribute(J),Rt=2);const Ct=J.drawRange,It=J.attributes.position;let Bt=Ct.start*Rt,de=(Ct.start+Ct.count)*Rt;gt!==null&&(Bt=Math.max(Bt,gt.start*Rt),de=Math.min(de,(gt.start+gt.count)*Rt)),Ut!==null?(Bt=Math.max(Bt,0),de=Math.min(de,Ut.count)):It!=null&&(Bt=Math.max(Bt,0),de=Math.min(de,It.count));const Ne=de-Bt;if(Ne<0||Ne===1/0)return;I.setup(W,R,Tt,J,Ut);let tn,_t=at;if(Ut!==null&&(tn=qt.get(Ut),_t=bt,_t.setIndex(tn)),W.isMesh)R.wireframe===!0?(ht.setLineWidth(R.wireframeLinewidth*st()),_t.setMode(1)):_t.setMode(4);else if(W.isLine){let Lt=R.linewidth;Lt===void 0&&(Lt=1),ht.setLineWidth(Lt*st()),W.isLineSegments?_t.setMode(1):W.isLineLoop?_t.setMode(2):_t.setMode(3)}else W.isPoints?_t.setMode(0):W.isSprite&&_t.setMode(4);if(W.isInstancedMesh)_t.renderInstances(Bt,Ne,W.count);else if(J.isInstancedBufferGeometry){const Lt=J._maxInstanceCount!==void 0?J._maxInstanceCount:1/0,Di=Math.min(J.instanceCount,Lt);_t.renderInstances(Bt,Ne,Di)}else _t.render(Bt,Ne)},this.compile=function(A,D){function J(R,W,gt){R.transparent===!0&&R.side===_e?(R.side=Me,R.needsUpdate=!0,ye(R,W,gt),R.side=Jn,R.needsUpdate=!0,ye(R,W,gt),R.side=_e):ye(R,W,gt)}f=v.get(A),f.init(),b.push(f),A.traverseVisible(function(R){R.isLight&&R.layers.test(D.layers)&&(f.pushLight(R),R.castShadow&&f.pushShadow(R))}),f.setupLights(p.physicallyCorrectLights),A.traverse(function(R){const W=R.material;if(W)if(Array.isArray(W))for(let gt=0;gt<W.length;gt++){const yt=W[gt];J(yt,A,R)}else J(W,A,R)}),b.pop(),f=null};let B=null;function Q(A){B&&B(A)}function ct(){Ft.stop()}function mt(){Ft.start()}const Ft=new ba;Ft.setAnimationLoop(Q),typeof self<"u"&&Ft.setContext(self),this.setAnimationLoop=function(A){B=A,ot.setAnimationLoop(A),A===null?Ft.stop():Ft.start()},ot.addEventListener("sessionstart",ct),ot.addEventListener("sessionend",mt),this.render=function(A,D){if(D!==void 0&&D.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(h===!0)return;A.matrixWorldAutoUpdate===!0&&A.updateMatrixWorld(),D.parent===null&&D.matrixWorldAutoUpdate===!0&&D.updateMatrixWorld(),ot.enabled===!0&&ot.isPresenting===!0&&(ot.cameraAutoUpdate===!0&&ot.updateCamera(D),D=ot.getCamera()),A.isScene===!0&&A.onBeforeRender(p,A,D,T),f=v.get(A,b.length),f.init(),b.push(f),K.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse),z.setFromProjectionMatrix(K),et=this.localClippingEnabled,q=x.init(this.clippingPlanes,et,D),d=le.get(A,m.length),d.init(),m.push(d),Yt(A,D,0,p.sortObjects),d.finish(),p.sortObjects===!0&&d.sort(rt,V),q===!0&&x.beginShadows();const J=f.state.shadowsArray;if(O.render(J,A,D),q===!0&&x.endShadows(),this.info.autoReset===!0&&this.info.reset(),$.render(d,A),f.setupLights(p.physicallyCorrectLights),D.isArrayCamera){const R=D.cameras;for(let W=0,gt=R.length;W<gt;W++){const yt=R[W];ee(d,A,yt,yt.viewport)}}else ee(d,A,D);T!==null&&(xt.updateMultisampleRenderTarget(T),xt.updateRenderTargetMipmap(T)),A.isScene===!0&&A.onAfterRender(p,A,D),I.resetDefaultState(),M=-1,y=null,b.pop(),b.length>0?f=b[b.length-1]:f=null,m.pop(),m.length>0?d=m[m.length-1]:d=null};function Yt(A,D,J,R){if(A.visible===!1)return;if(A.layers.test(D.layers)){if(A.isGroup)J=A.renderOrder;else if(A.isLOD)A.autoUpdate===!0&&A.update(D);else if(A.isLight)f.pushLight(A),A.castShadow&&f.pushShadow(A);else if(A.isSprite){if(!A.frustumCulled||z.intersectsSprite(A)){R&&Y.setFromMatrixPosition(A.matrixWorld).applyMatrix4(K);const yt=Jt.update(A),Tt=A.material;Tt.visible&&d.push(A,yt,Tt,J,Y.z,null)}}else if((A.isMesh||A.isLine||A.isPoints)&&(A.isSkinnedMesh&&A.skeleton.frame!==Pt.render.frame&&(A.skeleton.update(),A.skeleton.frame=Pt.render.frame),!A.frustumCulled||z.intersectsObject(A))){R&&Y.setFromMatrixPosition(A.matrixWorld).applyMatrix4(K);const yt=Jt.update(A),Tt=A.material;if(Array.isArray(Tt)){const Ut=yt.groups;for(let Rt=0,Ct=Ut.length;Rt<Ct;Rt++){const It=Ut[Rt],Bt=Tt[It.materialIndex];Bt&&Bt.visible&&d.push(A,yt,Bt,J,Y.z,It)}}else Tt.visible&&d.push(A,yt,Tt,J,Y.z,null)}}const gt=A.children;for(let yt=0,Tt=gt.length;yt<Tt;yt++)Yt(gt[yt],D,J,R)}function ee(A,D,J,R){const W=A.opaque,gt=A.transmissive,yt=A.transparent;f.setupLightsView(J),gt.length>0&&$e(W,D,J),R&&ht.viewport(E.copy(R)),W.length>0&&Kt(W,D,J),gt.length>0&&Kt(gt,D,J),yt.length>0&&Kt(yt,D,J),ht.buffers.depth.setTest(!0),ht.buffers.depth.setMask(!0),ht.buffers.color.setMask(!0),ht.setPolygonOffset(!1)}function $e(A,D,J){const R=St.isWebGL2;X===null&&(X=new gn(1,1,{generateMipmaps:!0,type:dt.has("EXT_color_buffer_half_float")?ti:pn,minFilter:Pi,samples:R&&r===!0?4:0})),p.getDrawingBufferSize(_),R?X.setSize(_.x,_.y):X.setSize(wr(_.x),wr(_.y));const W=p.getRenderTarget();p.setRenderTarget(X),p.clear();const gt=p.toneMapping;p.toneMapping=He,Kt(A,D,J),p.toneMapping=gt,xt.updateMultisampleRenderTarget(X),xt.updateRenderTargetMipmap(X),p.setRenderTarget(W)}function Kt(A,D,J){const R=D.isScene===!0?D.overrideMaterial:null;for(let W=0,gt=A.length;W<gt;W++){const yt=A[W],Tt=yt.object,Ut=yt.geometry,Rt=R===null?yt.material:R,Ct=yt.group;Tt.layers.test(J.layers)&&Fe(Tt,D,J,Ut,Rt,Ct)}}function Fe(A,D,J,R,W,gt){A.onBeforeRender(p,D,J,R,W,gt),A.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse,A.matrixWorld),A.normalMatrix.getNormalMatrix(A.modelViewMatrix),W.onBeforeRender(p,D,J,R,A,gt),W.transparent===!0&&W.side===_e?(W.side=Me,W.needsUpdate=!0,p.renderBufferDirect(J,D,R,W,A,gt),W.side=Jn,W.needsUpdate=!0,p.renderBufferDirect(J,D,R,W,A,gt),W.side=_e):p.renderBufferDirect(J,D,R,W,A,gt),A.onAfterRender(p,D,J,R,W,gt)}function ye(A,D,J){D.isScene!==!0&&(D=tt);const R=At.get(A),W=f.state.lights,gt=f.state.shadowsArray,yt=W.state.version,Tt=Nt.getParameters(A,W.state,gt,D,J),Ut=Nt.getProgramCacheKey(Tt);let Rt=R.programs;R.environment=A.isMeshStandardMaterial?D.environment:null,R.fog=D.fog,R.envMap=(A.isMeshStandardMaterial?Wt:Zt).get(A.envMap||R.environment),Rt===void 0&&(A.addEventListener("dispose",Et),Rt=new Map,R.programs=Rt);let Ct=Rt.get(Ut);if(Ct!==void 0){if(R.currentProgram===Ct&&R.lightsStateVersion===yt)return Fr(A,Tt),Ct}else Tt.uniforms=Nt.getUniforms(A),A.onBuild(J,Tt,p),A.onBeforeCompile(Tt,p),Ct=Nt.acquireProgram(Tt,Ut),Rt.set(Ut,Ct),R.uniforms=Tt.uniforms;const It=R.uniforms;(!A.isShaderMaterial&&!A.isRawShaderMaterial||A.clipping===!0)&&(It.clippingPlanes=x.uniform),Fr(A,Tt),R.needsLights=Ea(A),R.lightsStateVersion=yt,R.needsLights&&(It.ambientLightColor.value=W.state.ambient,It.lightProbe.value=W.state.probe,It.directionalLights.value=W.state.directional,It.directionalLightShadows.value=W.state.directionalShadow,It.spotLights.value=W.state.spot,It.spotLightShadows.value=W.state.spotShadow,It.rectAreaLights.value=W.state.rectArea,It.ltc_1.value=W.state.rectAreaLTC1,It.ltc_2.value=W.state.rectAreaLTC2,It.pointLights.value=W.state.point,It.pointLightShadows.value=W.state.pointShadow,It.hemisphereLights.value=W.state.hemi,It.directionalShadowMap.value=W.state.directionalShadowMap,It.directionalShadowMatrix.value=W.state.directionalShadowMatrix,It.spotShadowMap.value=W.state.spotShadowMap,It.spotLightMatrix.value=W.state.spotLightMatrix,It.spotLightMap.value=W.state.spotLightMap,It.pointShadowMap.value=W.state.pointShadowMap,It.pointShadowMatrix.value=W.state.pointShadowMatrix);const Bt=Ct.getUniforms(),de=Li.seqWithValue(Bt.seq,It);return R.currentProgram=Ct,R.uniformsList=de,Ct}function Fr(A,D){const J=At.get(A);J.outputEncoding=D.outputEncoding,J.instancing=D.instancing,J.skinning=D.skinning,J.morphTargets=D.morphTargets,J.morphNormals=D.morphNormals,J.morphColors=D.morphColors,J.morphTargetsCount=D.morphTargetsCount,J.numClippingPlanes=D.numClippingPlanes,J.numIntersection=D.numClipIntersection,J.vertexAlphas=D.vertexAlphas,J.vertexTangents=D.vertexTangents,J.toneMapping=D.toneMapping}function ka(A,D,J,R,W){D.isScene!==!0&&(D=tt),xt.resetTextureUnits();const gt=D.fog,yt=R.isMeshStandardMaterial?D.environment:null,Tt=T===null?p.outputEncoding:T.isXRRenderTarget===!0?T.texture.encoding:mn,Ut=(R.isMeshStandardMaterial?Wt:Zt).get(R.envMap||yt),Rt=R.vertexColors===!0&&!!J.attributes.color&&J.attributes.color.itemSize===4,Ct=!!R.normalMap&&!!J.attributes.tangent,It=!!J.morphAttributes.position,Bt=!!J.morphAttributes.normal,de=!!J.morphAttributes.color,Ne=R.toneMapped?p.toneMapping:He,tn=J.morphAttributes.position||J.morphAttributes.normal||J.morphAttributes.color,_t=tn!==void 0?tn.length:0,Lt=At.get(R),Di=f.state.lights;if(q===!0&&(et===!0||A!==y)){const fe=A===y&&R.id===M;x.setState(R,A,fe)}let Xt=!1;R.version===Lt.__version?(Lt.needsLights&&Lt.lightsStateVersion!==Di.state.version||Lt.outputEncoding!==Tt||W.isInstancedMesh&&Lt.instancing===!1||!W.isInstancedMesh&&Lt.instancing===!0||W.isSkinnedMesh&&Lt.skinning===!1||!W.isSkinnedMesh&&Lt.skinning===!0||Lt.envMap!==Ut||R.fog===!0&&Lt.fog!==gt||Lt.numClippingPlanes!==void 0&&(Lt.numClippingPlanes!==x.numPlanes||Lt.numIntersection!==x.numIntersection)||Lt.vertexAlphas!==Rt||Lt.vertexTangents!==Ct||Lt.morphTargets!==It||Lt.morphNormals!==Bt||Lt.morphColors!==de||Lt.toneMapping!==Ne||St.isWebGL2===!0&&Lt.morphTargetsCount!==_t)&&(Xt=!0):(Xt=!0,Lt.__version=R.version);let en=Lt.currentProgram;Xt===!0&&(en=ye(R,D,W));let Nr=!1,Gn=!1,Vi=!1;const se=en.getUniforms(),nn=Lt.uniforms;if(ht.useProgram(en.program)&&(Nr=!0,Gn=!0,Vi=!0),R.id!==M&&(M=R.id,Gn=!0),Nr||y!==A){if(se.setValue(H,"projectionMatrix",A.projectionMatrix),St.logarithmicDepthBuffer&&se.setValue(H,"logDepthBufFC",2/(Math.log(A.far+1)/Math.LN2)),y!==A&&(y=A,Gn=!0,Vi=!0),R.isShaderMaterial||R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshStandardMaterial||R.envMap){const fe=se.map.cameraPosition;fe!==void 0&&fe.setValue(H,Y.setFromMatrixPosition(A.matrixWorld))}(R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshLambertMaterial||R.isMeshBasicMaterial||R.isMeshStandardMaterial||R.isShaderMaterial)&&se.setValue(H,"isOrthographic",A.isOrthographicCamera===!0),(R.isMeshPhongMaterial||R.isMeshToonMaterial||R.isMeshLambertMaterial||R.isMeshBasicMaterial||R.isMeshStandardMaterial||R.isShaderMaterial||R.isShadowMaterial||W.isSkinnedMesh)&&se.setValue(H,"viewMatrix",A.matrixWorldInverse)}if(W.isSkinnedMesh){se.setOptional(H,W,"bindMatrix"),se.setOptional(H,W,"bindMatrixInverse");const fe=W.skeleton;fe&&(St.floatVertexTextures?(fe.boneTexture===null&&fe.computeBoneTexture(),se.setValue(H,"boneTexture",fe.boneTexture,xt),se.setValue(H,"boneTextureSize",fe.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Ki=J.morphAttributes;if((Ki.position!==void 0||Ki.normal!==void 0||Ki.color!==void 0&&St.isWebGL2===!0)&&nt.update(W,J,R,en),(Gn||Lt.receiveShadow!==W.receiveShadow)&&(Lt.receiveShadow=W.receiveShadow,se.setValue(H,"receiveShadow",W.receiveShadow)),R.isMeshGouraudMaterial&&R.envMap!==null&&(nn.envMap.value=Ut,nn.flipEnvMap.value=Ut.isCubeTexture&&Ut.isRenderTargetTexture===!1?-1:1),Gn&&(se.setValue(H,"toneMappingExposure",p.toneMappingExposure),Lt.needsLights&&wa(nn,Vi),gt&&R.fog===!0&&be.refreshFogUniforms(nn,gt),be.refreshMaterialUniforms(nn,R,G,L,X),Li.upload(H,Lt.uniformsList,nn,xt)),R.isShaderMaterial&&R.uniformsNeedUpdate===!0&&(Li.upload(H,Lt.uniformsList,nn,xt),R.uniformsNeedUpdate=!1),R.isSpriteMaterial&&se.setValue(H,"center",W.center),se.setValue(H,"modelViewMatrix",W.modelViewMatrix),se.setValue(H,"normalMatrix",W.normalMatrix),se.setValue(H,"modelMatrix",W.matrixWorld),R.isShaderMaterial||R.isRawShaderMaterial){const fe=R.uniformsGroups;for(let Oi=0,Ca=fe.length;Oi<Ca;Oi++)if(St.isWebGL2){const Dr=fe[Oi];lt.update(Dr,en),lt.bind(Dr,en)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return en}function wa(A,D){A.ambientLightColor.needsUpdate=D,A.lightProbe.needsUpdate=D,A.directionalLights.needsUpdate=D,A.directionalLightShadows.needsUpdate=D,A.pointLights.needsUpdate=D,A.pointLightShadows.needsUpdate=D,A.spotLights.needsUpdate=D,A.spotLightShadows.needsUpdate=D,A.rectAreaLights.needsUpdate=D,A.hemisphereLights.needsUpdate=D}function Ea(A){return A.isMeshLambertMaterial||A.isMeshToonMaterial||A.isMeshPhongMaterial||A.isMeshStandardMaterial||A.isShadowMaterial||A.isShaderMaterial&&A.lights===!0}this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return k},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(A,D,J){At.get(A.texture).__webglTexture=D,At.get(A.depthTexture).__webglTexture=J;const R=At.get(A);R.__hasExternalTextures=!0,R.__hasExternalTextures&&(R.__autoAllocateDepthBuffer=J===void 0,R.__autoAllocateDepthBuffer||dt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),R.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(A,D){const J=At.get(A);J.__webglFramebuffer=D,J.__useDefaultFramebuffer=D===void 0},this.setRenderTarget=function(A,D=0,J=0){T=A,S=D,k=J;let R=!0,W=null,gt=!1,yt=!1;if(A){const Ut=At.get(A);Ut.__useDefaultFramebuffer!==void 0?(ht.bindFramebuffer(36160,null),R=!1):Ut.__webglFramebuffer===void 0?xt.setupRenderTarget(A):Ut.__hasExternalTextures&&xt.rebindTextures(A,At.get(A.texture).__webglTexture,At.get(A.depthTexture).__webglTexture);const Rt=A.texture;(Rt.isData3DTexture||Rt.isDataArrayTexture||Rt.isCompressedArrayTexture)&&(yt=!0);const Ct=At.get(A).__webglFramebuffer;A.isWebGLCubeRenderTarget?(W=Ct[D],gt=!0):St.isWebGL2&&A.samples>0&&xt.useMultisampledRTT(A)===!1?W=At.get(A).__webglMultisampledFramebuffer:W=Ct,E.copy(A.viewport),P.copy(A.scissor),g=A.scissorTest}else E.copy(F).multiplyScalar(G).floor(),P.copy(j).multiplyScalar(G).floor(),g=Z;if(ht.bindFramebuffer(36160,W)&&St.drawBuffers&&R&&ht.drawBuffers(A,W),ht.viewport(E),ht.scissor(P),ht.setScissorTest(g),gt){const Ut=At.get(A.texture);H.framebufferTexture2D(36160,36064,34069+D,Ut.__webglTexture,J)}else if(yt){const Ut=At.get(A.texture),Rt=D||0;H.framebufferTextureLayer(36160,36064,Ut.__webglTexture,J||0,Rt)}M=-1},this.readRenderTargetPixels=function(A,D,J,R,W,gt,yt){if(!(A&&A.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Tt=At.get(A).__webglFramebuffer;if(A.isWebGLCubeRenderTarget&&yt!==void 0&&(Tt=Tt[yt]),Tt){ht.bindFramebuffer(36160,Tt);try{const Ut=A.texture,Rt=Ut.format,Ct=Ut.type;if(Rt!==Ee&&U.convert(Rt)!==H.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const It=Ct===ti&&(dt.has("EXT_color_buffer_half_float")||St.isWebGL2&&dt.has("EXT_color_buffer_float"));if(Ct!==pn&&U.convert(Ct)!==H.getParameter(35738)&&!(Ct===hn&&(St.isWebGL2||dt.has("OES_texture_float")||dt.has("WEBGL_color_buffer_float")))&&!It){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}D>=0&&D<=A.width-R&&J>=0&&J<=A.height-W&&H.readPixels(D,J,R,W,U.convert(Rt),U.convert(Ct),gt)}finally{const Ut=T!==null?At.get(T).__webglFramebuffer:null;ht.bindFramebuffer(36160,Ut)}}},this.copyFramebufferToTexture=function(A,D,J=0){const R=Math.pow(2,-J),W=Math.floor(D.image.width*R),gt=Math.floor(D.image.height*R);xt.setTexture2D(D,0),H.copyTexSubImage2D(3553,J,0,0,A.x,A.y,W,gt),ht.unbindTexture()},this.copyTextureToTexture=function(A,D,J,R=0){const W=D.image.width,gt=D.image.height,yt=U.convert(J.format),Tt=U.convert(J.type);xt.setTexture2D(J,0),H.pixelStorei(37440,J.flipY),H.pixelStorei(37441,J.premultiplyAlpha),H.pixelStorei(3317,J.unpackAlignment),D.isDataTexture?H.texSubImage2D(3553,R,A.x,A.y,W,gt,yt,Tt,D.image.data):D.isCompressedTexture?H.compressedTexSubImage2D(3553,R,A.x,A.y,D.mipmaps[0].width,D.mipmaps[0].height,yt,D.mipmaps[0].data):H.texSubImage2D(3553,R,A.x,A.y,yt,Tt,D.image),R===0&&J.generateMipmaps&&H.generateMipmap(3553),ht.unbindTexture()},this.copyTextureToTexture3D=function(A,D,J,R,W=0){if(p.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const gt=A.max.x-A.min.x+1,yt=A.max.y-A.min.y+1,Tt=A.max.z-A.min.z+1,Ut=U.convert(R.format),Rt=U.convert(R.type);let Ct;if(R.isData3DTexture)xt.setTexture3D(R,0),Ct=32879;else if(R.isDataArrayTexture)xt.setTexture2DArray(R,0),Ct=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}H.pixelStorei(37440,R.flipY),H.pixelStorei(37441,R.premultiplyAlpha),H.pixelStorei(3317,R.unpackAlignment);const It=H.getParameter(3314),Bt=H.getParameter(32878),de=H.getParameter(3316),Ne=H.getParameter(3315),tn=H.getParameter(32877),_t=J.isCompressedTexture?J.mipmaps[0]:J.image;H.pixelStorei(3314,_t.width),H.pixelStorei(32878,_t.height),H.pixelStorei(3316,A.min.x),H.pixelStorei(3315,A.min.y),H.pixelStorei(32877,A.min.z),J.isDataTexture||J.isData3DTexture?H.texSubImage3D(Ct,W,D.x,D.y,D.z,gt,yt,Tt,Ut,Rt,_t.data):J.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),H.compressedTexSubImage3D(Ct,W,D.x,D.y,D.z,gt,yt,Tt,Ut,_t.data)):H.texSubImage3D(Ct,W,D.x,D.y,D.z,gt,yt,Tt,Ut,Rt,_t),H.pixelStorei(3314,It),H.pixelStorei(32878,Bt),H.pixelStorei(3316,de),H.pixelStorei(3315,Ne),H.pixelStorei(32877,tn),W===0&&R.generateMipmaps&&H.generateMipmap(Ct),ht.unbindTexture()},this.initTexture=function(A){A.isCubeTexture?xt.setTextureCube(A,0):A.isData3DTexture?xt.setTexture3D(A,0):A.isDataArrayTexture||A.isCompressedArrayTexture?xt.setTexture2DArray(A,0):xt.setTexture2D(A,0),ht.unbindTexture()},this.resetState=function(){S=0,k=0,T=null,ht.reset(),I.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class wd extends Ta{}wd.prototype.isWebGL1Renderer=!0;class Ed extends ie{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.backgroundIntensity=this.backgroundIntensity),e}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(t){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=t}}class Pr extends Xe{constructor(t=1,e=32,n=16,i=0,r=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:o,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const c=Math.min(o+a,Math.PI);let l=0;const u=[],d=new N,f=new N,m=[],b=[],p=[],h=[];for(let S=0;S<=n;S++){const k=[],T=S/n;let M=0;S==0&&o==0?M=.5/e:S==n&&c==Math.PI&&(M=-.5/e);for(let y=0;y<=e;y++){const E=y/e;d.x=-t*Math.cos(i+E*r)*Math.sin(o+T*a),d.y=t*Math.cos(o+T*a),d.z=t*Math.sin(i+E*r)*Math.sin(o+T*a),b.push(d.x,d.y,d.z),f.copy(d).normalize(),p.push(f.x,f.y,f.z),h.push(E+M,1-T),k.push(l++)}u.push(k)}for(let S=0;S<n;S++)for(let k=0;k<e;k++){const T=u[S][k+1],M=u[S][k],y=u[S+1][k],E=u[S+1][k+1];(S!==0||o>0)&&m.push(T,M,E),(S!==n-1||c<Math.PI)&&m.push(M,y,E)}this.setIndex(m),this.setAttribute("position",new Pe(b,3)),this.setAttribute("normal",new Pe(p,3)),this.setAttribute("uv",new Pe(h,2))}static fromJSON(t){return new Pr(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class js extends ai{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Vt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=aa,this.normalScale=new Mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}const zs={enabled:!1,files:{},add:function(s,t){this.enabled!==!1&&(this.files[s]=t)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class Cd{constructor(t,e,n){const i=this;let r=!1,o=0,a=0,c;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(u){a++,r===!1&&i.onStart!==void 0&&i.onStart(u,o,a),r=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return c?c(u):u},this.setURLModifier=function(u){return c=u,this},this.addHandler=function(u,d){return l.push(u,d),this},this.removeHandler=function(u){const d=l.indexOf(u);return d!==-1&&l.splice(d,2),this},this.getHandler=function(u){for(let d=0,f=l.length;d<f;d+=2){const m=l[d],b=l[d+1];if(m.global&&(m.lastIndex=0),m.test(u))return b}return null}}}const Id=new Cd;class Ua{constructor(t){this.manager=t!==void 0?t:Id,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}class Ld extends Ua{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=zs.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const a=ni("img");function c(){u(),zs.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(d){u(),i&&i(d),r.manager.itemError(t),r.manager.itemEnd(t)}function u(){a.removeEventListener("load",c,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",c,!1),a.addEventListener("error",l,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class Rd extends Ua{constructor(t){super(t)}load(t,e,n,i){const r=new he,o=new Ld(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,function(a){r.image=a,r.needsUpdate=!0,e!==void 0&&e(r)},n,i),r}}class Pd extends ie{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new Vt(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}const br=new jt,Qs=new N,Zs=new N;class Fd{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Mt(512,512),this.map=null,this.mapPass=null,this.matrix=new jt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Lr,this._frameExtents=new Mt(1,1),this._viewportCount=1,this._viewports=[new te(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Qs.setFromMatrixPosition(t.matrixWorld),e.position.copy(Qs),Zs.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Zs),e.updateMatrixWorld(),br.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(br),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(br)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Nd extends Fd{constructor(){super(new Se(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,n=kr*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;(n!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Dd extends Pd{constructor(t,e,n=0,i=Math.PI/3,r=0,o=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(ie.DefaultUp),this.updateMatrix(),this.target=new ie,this.distance=n,this.angle=i,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new Nd}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Ys{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(ue(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Cr}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Cr);const Xs={type:"change"},yr={type:"start"},$s={type:"end"};class Vd extends bn{constructor(t,e){super(),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new N,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:yn.ROTATE,MIDDLE:yn.DOLLY,RIGHT:yn.PAN},this.touches={ONE:An.ROTATE,TWO:An.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(U){U.addEventListener("keydown",le),this._domElementKeyEvents=U},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Xs),n.update(),r=i.NONE},this.update=function(){const U=new N,I=new Sn().setFromUnitVectors(t.up,new N(0,1,0)),lt=I.clone().invert(),ut=new N,ot=new Sn,pt=2*Math.PI;return function(){const wt=n.object.position;U.copy(wt).sub(n.target),U.applyQuaternion(I),a.setFromVector3(U),n.autoRotate&&r===i.NONE&&w(P()),n.enableDamping?(a.theta+=c.theta*n.dampingFactor,a.phi+=c.phi*n.dampingFactor):(a.theta+=c.theta,a.phi+=c.phi);let Et=n.minAzimuthAngle,Dt=n.maxAzimuthAngle;return isFinite(Et)&&isFinite(Dt)&&(Et<-Math.PI?Et+=pt:Et>Math.PI&&(Et-=pt),Dt<-Math.PI?Dt+=pt:Dt>Math.PI&&(Dt-=pt),Et<=Dt?a.theta=Math.max(Et,Math.min(Dt,a.theta)):a.theta=a.theta>(Et+Dt)/2?Math.max(Et,a.theta):Math.min(Dt,a.theta)),a.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=l,a.radius=Math.max(n.minDistance,Math.min(n.maxDistance,a.radius)),n.enableDamping===!0?n.target.addScaledVector(u,n.dampingFactor):n.target.add(u),U.setFromSpherical(a),U.applyQuaternion(lt),wt.copy(n.target).add(U),n.object.lookAt(n.target),n.enableDamping===!0?(c.theta*=1-n.dampingFactor,c.phi*=1-n.dampingFactor,u.multiplyScalar(1-n.dampingFactor)):(c.set(0,0,0),u.set(0,0,0)),l=1,d||ut.distanceToSquared(n.object.position)>o||8*(1-ot.dot(n.object.quaternion))>o?(n.dispatchEvent(Xs),ut.copy(n.object.position),ot.copy(n.object.quaternion),d=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",O),n.domElement.removeEventListener("pointerdown",Zt),n.domElement.removeEventListener("pointercancel",re),n.domElement.removeEventListener("wheel",be),n.domElement.removeEventListener("pointermove",Wt),n.domElement.removeEventListener("pointerup",qt),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",le)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=i.NONE;const o=1e-6,a=new Ys,c=new Ys;let l=1;const u=new N;let d=!1;const f=new Mt,m=new Mt,b=new Mt,p=new Mt,h=new Mt,S=new Mt,k=new Mt,T=new Mt,M=new Mt,y=[],E={};function P(){return 2*Math.PI/60/60*n.autoRotateSpeed}function g(){return Math.pow(.95,n.zoomSpeed)}function w(U){c.theta-=U}function L(U){c.phi-=U}const G=function(){const U=new N;return function(lt,ut){U.setFromMatrixColumn(ut,0),U.multiplyScalar(-lt),u.add(U)}}(),rt=function(){const U=new N;return function(lt,ut){n.screenSpacePanning===!0?U.setFromMatrixColumn(ut,1):(U.setFromMatrixColumn(ut,0),U.crossVectors(n.object.up,U)),U.multiplyScalar(lt),u.add(U)}}(),V=function(){const U=new N;return function(lt,ut){const ot=n.domElement;if(n.object.isPerspectiveCamera){const pt=n.object.position;U.copy(pt).sub(n.target);let ft=U.length();ft*=Math.tan(n.object.fov/2*Math.PI/180),G(2*lt*ft/ot.clientHeight,n.object.matrix),rt(2*ut*ft/ot.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(G(lt*(n.object.right-n.object.left)/n.object.zoom/ot.clientWidth,n.object.matrix),rt(ut*(n.object.top-n.object.bottom)/n.object.zoom/ot.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function F(U){n.object.isPerspectiveCamera?l/=U:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*U)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(U){n.object.isPerspectiveCamera?l*=U:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/U)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function Z(U){f.set(U.clientX,U.clientY)}function z(U){k.set(U.clientX,U.clientY)}function q(U){p.set(U.clientX,U.clientY)}function et(U){m.set(U.clientX,U.clientY),b.subVectors(m,f).multiplyScalar(n.rotateSpeed);const I=n.domElement;w(2*Math.PI*b.x/I.clientHeight),L(2*Math.PI*b.y/I.clientHeight),f.copy(m),n.update()}function X(U){T.set(U.clientX,U.clientY),M.subVectors(T,k),M.y>0?F(g()):M.y<0&&j(g()),k.copy(T),n.update()}function K(U){h.set(U.clientX,U.clientY),S.subVectors(h,p).multiplyScalar(n.panSpeed),V(S.x,S.y),p.copy(h),n.update()}function _(U){U.deltaY<0?j(g()):U.deltaY>0&&F(g()),n.update()}function Y(U){let I=!1;switch(U.code){case n.keys.UP:U.ctrlKey||U.metaKey||U.shiftKey?L(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):V(0,n.keyPanSpeed),I=!0;break;case n.keys.BOTTOM:U.ctrlKey||U.metaKey||U.shiftKey?L(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):V(0,-n.keyPanSpeed),I=!0;break;case n.keys.LEFT:U.ctrlKey||U.metaKey||U.shiftKey?w(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):V(n.keyPanSpeed,0),I=!0;break;case n.keys.RIGHT:U.ctrlKey||U.metaKey||U.shiftKey?w(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):V(-n.keyPanSpeed,0),I=!0;break}I&&(U.preventDefault(),n.update())}function tt(){if(y.length===1)f.set(y[0].pageX,y[0].pageY);else{const U=.5*(y[0].pageX+y[1].pageX),I=.5*(y[0].pageY+y[1].pageY);f.set(U,I)}}function st(){if(y.length===1)p.set(y[0].pageX,y[0].pageY);else{const U=.5*(y[0].pageX+y[1].pageX),I=.5*(y[0].pageY+y[1].pageY);p.set(U,I)}}function H(){const U=y[0].pageX-y[1].pageX,I=y[0].pageY-y[1].pageY,lt=Math.sqrt(U*U+I*I);k.set(0,lt)}function kt(){n.enableZoom&&H(),n.enablePan&&st()}function dt(){n.enableZoom&&H(),n.enableRotate&&tt()}function St(U){if(y.length==1)m.set(U.pageX,U.pageY);else{const lt=bt(U),ut=.5*(U.pageX+lt.x),ot=.5*(U.pageY+lt.y);m.set(ut,ot)}b.subVectors(m,f).multiplyScalar(n.rotateSpeed);const I=n.domElement;w(2*Math.PI*b.x/I.clientHeight),L(2*Math.PI*b.y/I.clientHeight),f.copy(m)}function ht(U){if(y.length===1)h.set(U.pageX,U.pageY);else{const I=bt(U),lt=.5*(U.pageX+I.x),ut=.5*(U.pageY+I.y);h.set(lt,ut)}S.subVectors(h,p).multiplyScalar(n.panSpeed),V(S.x,S.y),p.copy(h)}function Pt(U){const I=bt(U),lt=U.pageX-I.x,ut=U.pageY-I.y,ot=Math.sqrt(lt*lt+ut*ut);T.set(0,ot),M.set(0,Math.pow(T.y/k.y,n.zoomSpeed)),F(M.y),k.copy(T)}function At(U){n.enableZoom&&Pt(U),n.enablePan&&ht(U)}function xt(U){n.enableZoom&&Pt(U),n.enableRotate&&St(U)}function Zt(U){n.enabled!==!1&&(y.length===0&&(n.domElement.setPointerCapture(U.pointerId),n.domElement.addEventListener("pointermove",Wt),n.domElement.addEventListener("pointerup",qt)),$(U),U.pointerType==="touch"?v(U):Jt(U))}function Wt(U){n.enabled!==!1&&(U.pointerType==="touch"?x(U):Nt(U))}function qt(U){nt(U),y.length===0&&(n.domElement.releasePointerCapture(U.pointerId),n.domElement.removeEventListener("pointermove",Wt),n.domElement.removeEventListener("pointerup",qt)),n.dispatchEvent($s),r=i.NONE}function re(U){nt(U)}function Jt(U){let I;switch(U.button){case 0:I=n.mouseButtons.LEFT;break;case 1:I=n.mouseButtons.MIDDLE;break;case 2:I=n.mouseButtons.RIGHT;break;default:I=-1}switch(I){case yn.DOLLY:if(n.enableZoom===!1)return;z(U),r=i.DOLLY;break;case yn.ROTATE:if(U.ctrlKey||U.metaKey||U.shiftKey){if(n.enablePan===!1)return;q(U),r=i.PAN}else{if(n.enableRotate===!1)return;Z(U),r=i.ROTATE}break;case yn.PAN:if(U.ctrlKey||U.metaKey||U.shiftKey){if(n.enableRotate===!1)return;Z(U),r=i.ROTATE}else{if(n.enablePan===!1)return;q(U),r=i.PAN}break;default:r=i.NONE}r!==i.NONE&&n.dispatchEvent(yr)}function Nt(U){switch(r){case i.ROTATE:if(n.enableRotate===!1)return;et(U);break;case i.DOLLY:if(n.enableZoom===!1)return;X(U);break;case i.PAN:if(n.enablePan===!1)return;K(U);break}}function be(U){n.enabled===!1||n.enableZoom===!1||r!==i.NONE||(U.preventDefault(),n.dispatchEvent(yr),_(U),n.dispatchEvent($s))}function le(U){n.enabled===!1||n.enablePan===!1||Y(U)}function v(U){switch(at(U),y.length){case 1:switch(n.touches.ONE){case An.ROTATE:if(n.enableRotate===!1)return;tt(),r=i.TOUCH_ROTATE;break;case An.PAN:if(n.enablePan===!1)return;st(),r=i.TOUCH_PAN;break;default:r=i.NONE}break;case 2:switch(n.touches.TWO){case An.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;kt(),r=i.TOUCH_DOLLY_PAN;break;case An.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;dt(),r=i.TOUCH_DOLLY_ROTATE;break;default:r=i.NONE}break;default:r=i.NONE}r!==i.NONE&&n.dispatchEvent(yr)}function x(U){switch(at(U),r){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;St(U),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;ht(U),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;At(U),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;xt(U),n.update();break;default:r=i.NONE}}function O(U){n.enabled!==!1&&U.preventDefault()}function $(U){y.push(U)}function nt(U){delete E[U.pointerId];for(let I=0;I<y.length;I++)if(y[I].pointerId==U.pointerId){y.splice(I,1);return}}function at(U){let I=E[U.pointerId];I===void 0&&(I=new Mt,E[U.pointerId]=I),I.set(U.pageX,U.pageY)}function bt(U){const I=U.pointerId===y[0].pointerId?y[1]:y[0];return E[I.pointerId]}n.domElement.addEventListener("contextmenu",O),n.domElement.addEventListener("pointerdown",Zt),n.domElement.addEventListener("pointercancel",re),n.domElement.addEventListener("wheel",be,{passive:!1}),this.update()}}const Kd=s=>{let t;return s=="plane"?t="data:image/jpeg;base64,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":s=="shape"&&(t="data:image/jpeg;base64,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"),t};function Od(){const s=new Ta({alpha:!0});s.setClearColor(0,1),s.shadowMap.enabled=!0,document.querySelector("#container").appendChild(s.domElement);const e={width:window.innerWidth,height:window.innerHeight},n=new Ed,i=new Se(45,e.width/e.height,1,100);function r(E,P){var g=new Dd(E,P);return g.castShadow=!0,g.shadow.mapSize.x=4096,g.shadow.mapSize.y=4096,g}var o=r("rgb(145,200,255)",1),a=r("rgb(255,220,180)",1);n.add(o),n.add(a),i.position.x=4,i.position.y=8,i.position.z=11,i.lookAt(new N(0,0,0)),o.position.x=6,o.position.y=8,o.position.z=-20,a.position.x=-12,a.position.y=6,a.position.z=-10;const c=()=>new Vd(i,s.domElement);function l(E){var P=Kd(E);return P}var u=new Rd,d=u.load(l("plane")),f=u.load(l("shape")),m=6,b=["map","bumpMap","roughnessMap"];const p=E=>{var P=new Pr(E,24,24),g=new js({color:"gray",bumpMap:f,roughnessMap:f}),w=new Le(P,g),L=w.material;return w.castShadow=!0,w.position.y=w.geometry.parameters.radius,L.bumpScale=.01,L.roughness=.75,L.metalness=.25,w},h=(E,P)=>{var g=new Fi(E,P),w=new js({color:16777215,side:_e,map:d,bumpMap:d,roughnessMap:d}),L=new Le(g,w);L.castShadow=!0,L.receiveShadow=!0,L.rotation.x=Math.PI/2;const G=L.material;return G.roughness=.65,G.metalness=.75,G.bumpScale=.01,b.forEach(rt=>{G[rt].wrapS=$n,G[rt].wrapT=$n,G[rt].repeat.set(m,m)}),L},S=()=>{var E=p(1),P=h(50,50);return n.add(E,P),{sphere:E,plane:P}},k=()=>{e.width=window.innerWidth,e.height=window.innerHeight,i.aspect=e.width/e.height,i.updateProjectionMatrix(),s.setSize(e.width,e.height),s.setPixelRatio(Math.min(window.devicePixelRatio,2))},T=()=>{window.addEventListener("resize",k),window.addEventListener("scroll",()=>{}),window.addEventListener("mousedown",E=>{}),window.addEventListener("mouseup",E=>{})},M=(E,P)=>{o.intensity+=(Math.random()-.5)*.15,o.intensity=Math.abs(o.intensity),a.intensity+=(Math.random()-.5)*.05,a.intensity=Math.abs(a.intensity),P.update(),s.render(n,i),requestAnimationFrame(()=>{M(E,P)})};(()=>{const E=S(),P=c();T(),k(),M(E,P)})()}Od();
